<#
.SYNOPSIS
    EST (Enrollment over Secure Transport) client module for initial certificate enrollment.

.DESCRIPTION
    EstClient.psm1 implements EST protocol (RFC 7030) initial enrollment functionality for
    automated client certificate lifecycle management. This module provides the core
    enrollment operation used by the ECA-EST agent to obtain client certificates from
    step-ca PKI using bootstrap token authentication.

    Features:
    - Initial enrollment via /simpleenroll endpoint (bootstrap token authentication)
    - PKCS#10 CSR encoding and transmission (PEM to base64-encoded DER)
    - PKCS#7 certificate response parsing using .NET SignedCms class
    - Comprehensive error handling for 401, 400, 500, network errors
    - Structured logging with automatic bootstrap token redaction
    - Content-Type validation for protocol compliance

    The module receives a pre-generated CSR in PEM format (from CryptoHelper module),
    converts it to the format required by EST protocol (base64-encoded DER), constructs
    the HTTP request with bootstrap token authentication, parses the PKCS#7 response,
    and returns the issued certificate in PEM format.

.NOTES
    Module Name: EstClient
    Author: Edge Certificate Agent Project
    Requires: PowerShell Core 7.0+
    Dependencies:
      - Logger module (for structured logging)
      - .NET System.Security.Cryptography.Pkcs (for PKCS#7 parsing)

    Protocol Compliance:
    - RFC 7030 (EST Protocol)
    - RFC 2986 (PKCS#10 CSR format)
    - RFC 5652 (PKCS#7/CMS format)
    - RFC 4648 (Base64 encoding)

    Security:
    - Bootstrap tokens are NEVER logged in plain text
    - All logging uses redacted token representations
    - Content-Type validation prevents protocol confusion attacks
    - Error messages sanitized to prevent credential leakage

.EXAMPLE
    Import-Module ./agents/est/EstClient.psm1

    # Generate CSR using CryptoHelper
    $rsa = New-RSAKeyPair
    $csrPem = New-CertificateRequest -SubjectDN "CN=client-device-001" -SubjectAlternativeNames @() -RsaKey $rsa

    # Perform initial enrollment
    $certPem = Invoke-EstEnrollment `
        -PkiUrl "https://pki:9000" `
        -ProvisionerName "est-provisioner" `
        -CsrPem $csrPem `
        -BootstrapToken $env:EST_BOOTSTRAP_TOKEN

    # Install certificate to volume
    Set-Content -Path "/certs/client/client.crt" -Value $certPem

.LINK
    EST Protocol Reference: docs/api/est_protocol_reference.md
    Architecture: docs/02_Architecture_Overview.md
#>

#Requires -Version 7.0

using namespace System.Security.Cryptography.Pkcs

# Resolve shared module directory (container: /agent/common, repo: agents/common)
$commonDirCandidates = @()

$localCommon = Join-Path $PSScriptRoot 'common'
if (Test-Path (Join-Path $localCommon 'Logger.psm1')) {
    $commonDirCandidates += $localCommon
}

$parentDir = Split-Path $PSScriptRoot -Parent
if (-not [string]::IsNullOrWhiteSpace($parentDir)) {
    $parentCommon = Join-Path $parentDir 'common'
    if (Test-Path (Join-Path $parentCommon 'Logger.psm1')) {
        $commonDirCandidates += $parentCommon
    }
}

$commonDir = $commonDirCandidates | Select-Object -First 1
if (-not $commonDir) {
    throw "EstClient: unable to locate common module directory relative to $PSScriptRoot."
}

# Import required shared modules
Import-Module (Join-Path $commonDir 'Logger.psm1') -Force -Global
if (Test-Path (Join-Path $commonDir 'CryptoHelper.psm1')) {
    Import-Module (Join-Path $commonDir 'CryptoHelper.psm1') -Force -Global
}

# ============================================================================
# INTERNAL HELPER FUNCTIONS
# ============================================================================

<#
.SYNOPSIS
    Internal helper - Converts PEM-encoded content to DER binary format.

.DESCRIPTION
    Strips PEM headers and footers (e.g., -----BEGIN CERTIFICATE REQUEST-----)
    and decodes the base64 content to DER (Distinguished Encoding Rules) binary format.
    Used to convert CSR from PEM format (as generated by CryptoHelper) to DER format
    required for base64 encoding in EST HTTP transmission.

.PARAMETER PemContent
    The PEM-encoded content string (including headers and footers).

.PARAMETER Label
    The PEM label to strip (e.g., "CERTIFICATE REQUEST", "CERTIFICATE").

.OUTPUTS
    System.Byte[] - DER-encoded binary data.

.EXAMPLE
    $csrDer = ConvertFrom-PemToDer -PemContent $csrPem -Label "CERTIFICATE REQUEST"
    # Returns: DER-encoded CSR bytes
#>
function ConvertFrom-PemToDer {
    [CmdletBinding()]
    [OutputType([byte[]])]
    param(
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]$PemContent,

        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]$Label
    )

    try {
        # Remove PEM headers and footers
        $base64Content = $PemContent `
            -replace "-----BEGIN $Label-----", "" `
            -replace "-----END $Label-----", "" `
            -replace "`r", "" `
            -replace "`n", "" `
            -replace " ", ""

        # Decode base64 to DER bytes
        $derBytes = [Convert]::FromBase64String($base64Content)

        return $derBytes
    }
    catch {
        throw "Failed to convert PEM to DER: $($_.Exception.Message)"
    }
}

<#
.SYNOPSIS
    Internal helper - Converts DER binary format to PEM-encoded content.

.DESCRIPTION
    Base64-encodes DER binary data with line breaks and wraps it with PEM headers
    and footers. Used to convert certificate from DER format (extracted from PKCS#7)
    to PEM format for file storage.

.PARAMETER DerBytes
    The DER-encoded binary data.

.PARAMETER Label
    The PEM label to use in headers (e.g., "CERTIFICATE").

.OUTPUTS
    System.String - PEM-formatted string with headers and base64-encoded content.

.EXAMPLE
    $certPem = ConvertTo-PemFromDer -DerBytes $certDer -Label "CERTIFICATE"
    # Returns: -----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----
#>
function ConvertTo-PemFromDer {
    [CmdletBinding()]
    [OutputType([string])]
    param(
        [Parameter(Mandatory = $true)]
        [ValidateNotNull()]
        [byte[]]$DerBytes,

        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]$Label
    )

    try {
        # Convert DER bytes to base64 with line breaks (64 characters per line per RFC 7468)
        $base64 = [Convert]::ToBase64String($DerBytes, [Base64FormattingOptions]::InsertLineBreaks)

        # Wrap with PEM headers
        $pem = "-----BEGIN $Label-----`n$base64`n-----END $Label-----"

        return $pem
    }
    catch {
        throw "Failed to convert DER to PEM: $($_.Exception.Message)"
    }
}

<#
.SYNOPSIS
    Internal helper - Redacts bootstrap token for safe logging.

.DESCRIPTION
    Creates a redacted representation of a bootstrap token showing only the first
    and last few characters with asterisks in the middle. This prevents credential
    leakage in logs while still providing diagnostic value.

.PARAMETER Token
    The bootstrap token to redact.

.OUTPUTS
    System.String - Redacted token string (e.g., "facto-***-12345").

.EXAMPLE
    Get-RedactedToken -Token "factory-secret-token-12345"
    # Returns: "facto-***-12345"
#>
function Get-RedactedToken {
    [CmdletBinding()]
    [OutputType([string])]
    param(
        [Parameter(Mandatory = $false)]
        [AllowEmptyString()]
        [string]$Token
    )

    # Handle null or empty tokens
    if ([string]::IsNullOrEmpty($Token)) {
        return '***REDACTED***'
    }

    # For tokens shorter than 10 characters, fully redact
    if ($Token.Length -lt 10) {
        return '***REDACTED***'
    }

    # Show first 5 and last 5 characters with asterisks in middle
    $prefix = $Token.Substring(0, 5)
    $suffix = $Token.Substring($Token.Length - 5, 5)
    return "$prefix-***-$suffix"
}

<#
.SYNOPSIS
    Internal helper - Wraps Invoke-RestMethod to return structured response with headers and status code.

.DESCRIPTION
    This wrapper function encapsulates Invoke-RestMethod calls to make the EstClient module more testable.
    It captures response headers and status code using -ResponseHeadersVariable and -StatusCodeVariable
    parameters and returns them as a structured object along with the response body.

    This design allows tests to mock this function instead of Invoke-RestMethod, eliminating
    PowerShell scope issues when trying to set variables in the caller's scope during mocking.

.PARAMETER Uri
    The URI for the HTTP request.

.PARAMETER Method
    The HTTP method (GET, POST, etc.).

.PARAMETER Headers
    Optional hashtable of HTTP headers.

.PARAMETER ContentType
    Optional Content-Type header value.

.PARAMETER Body
    Optional request body.

.PARAMETER Certificate
    Optional X509Certificate2 object for mTLS authentication.

.OUTPUTS
    PSCustomObject with properties:
    - Body: The response body from Invoke-RestMethod
    - Headers: Hashtable of response headers
    - StatusCode: HTTP status code (integer)

.EXAMPLE
    $httpResponse = Invoke-EstHttpRequest `
        -Uri "https://pki/est/simpleenroll" `
        -Method Post `
        -Headers @{ Authorization = "Bearer token" } `
        -ContentType "application/pkcs10" `
        -Body $csrBase64

    # Access response data:
    $responseBody = $httpResponse.Body
    $contentType = $httpResponse.Headers['Content-Type']
    $statusCode = $httpResponse.StatusCode
#>
function Invoke-EstHttpRequest {
    [CmdletBinding()]
    [OutputType([PSCustomObject])]
    param(
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]$Uri,

        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]$Method,

        [Parameter(Mandatory = $false)]
        [hashtable]$Headers = @{},

        [Parameter(Mandatory = $false)]
        [string]$ContentType,

        [Parameter(Mandatory = $false)]
        [string]$Body,

        [Parameter(Mandatory = $false)]
        [System.Security.Cryptography.X509Certificates.X509Certificate2]$Certificate
    )

    # Variables to capture response metadata
    $responseHeaders = $null
    $statusCode = 0

    # Build Invoke-RestMethod parameter hashtable
    $params = @{
        Uri = $Uri
        Method = $Method
        Headers = $Headers
        ResponseHeadersVariable = 'responseHeaders'
        StatusCodeVariable = 'statusCode'
        SkipCertificateCheck = $true  # Skip SSL certificate validation (PoC)
    }

    # Add optional parameters only if provided
    if ($ContentType) {
        $params['ContentType'] = $ContentType
    }
    if ($Body) {
        $params['Body'] = $Body
    }
    if ($Certificate) {
        $params['Certificate'] = $Certificate
    }

    # Execute HTTP request
    $response = Invoke-RestMethod @params

    # Return structured response object
    return [PSCustomObject]@{
        Body = $response
        Headers = $responseHeaders
        StatusCode = $statusCode
    }
}

# ============================================================================
# PUBLIC FUNCTIONS
# ============================================================================

<#
.SYNOPSIS
    Performs EST initial enrollment to obtain a client certificate using bootstrap token authentication.

.DESCRIPTION
    Implements EST protocol (RFC 7030) /simpleenroll operation for initial certificate enrollment.
    This function:
    1. Converts CSR from PEM format to base64-encoded DER for EST transmission
    2. Constructs HTTP POST request to EST /simpleenroll endpoint
    3. Authenticates using HTTP Bearer token (bootstrap token)
    4. Validates response Content-Type (application/pkcs7-mime)
    5. Parses PKCS#7 response using .NET SignedCms class
    6. Extracts X.509 certificate from PKCS#7 container
    7. Converts certificate to PEM format
    8. Returns certificate PEM string

    Error Handling:
    - 401 Unauthorized: Invalid bootstrap token (throws exception with redacted token)
    - 400 Bad Request: Malformed CSR (throws exception with CSR details)
    - 500 Internal Server Error: CA error (throws exception)
    - Network errors: Connection timeout, DNS failure (throws exception)
    - Invalid response Content-Type: Throws exception

    Logging:
    - Info: "Sending EST enrollment request" (before HTTP request)
    - Info: "Certificate received: {subject}" (on success)
    - Error: "EST enrollment failed: {status_code}" (on errors)
    - Bootstrap token is NEVER logged in plain text (always redacted)

.PARAMETER PkiUrl
    The base URL of the step-ca PKI server (e.g., "https://pki:9000").
    Must be a valid HTTPS URL.

.PARAMETER ProvisionerName
    The EST provisioner name configured in step-ca (e.g., "est-provisioner").
    This is used to construct the EST endpoint URL.

.PARAMETER CsrPem
    The Certificate Signing Request in PEM format (as generated by CryptoHelper.New-CertificateRequest).
    Must include PEM headers (-----BEGIN CERTIFICATE REQUEST-----).

.PARAMETER BootstrapToken
    The bootstrap token for initial enrollment authentication.
    This is transmitted as HTTP Bearer token in the Authorization header.

.OUTPUTS
    System.String
    Returns the issued certificate in PEM format with headers:
    -----BEGIN CERTIFICATE-----
    [Base64-encoded certificate]
    -----END CERTIFICATE-----

.EXAMPLE
    $certPem = Invoke-EstEnrollment `
        -PkiUrl "https://pki:9000" `
        -ProvisionerName "est-provisioner" `
        -CsrPem $csrPem `
        -BootstrapToken "factory-secret-token-12345"

    # Returns: PEM-encoded X.509 certificate

.EXAMPLE
    try {
        $certPem = Invoke-EstEnrollment `
            -PkiUrl $env:PKI_URL `
            -ProvisionerName $env:EST_PROVISIONER `
            -CsrPem $csrPem `
            -BootstrapToken $env:EST_BOOTSTRAP_TOKEN

        Set-Content -Path "/certs/client/client.crt" -Value $certPem
    }
    catch {
        Write-LogError -Message "Initial enrollment failed" -Context @{
            error = $_.Exception.Message
        }
    }

.NOTES
    Protocol Compliance:
    - CSR encoding: PEM -> DER -> Base64 (no PEM headers in HTTP body)
    - HTTP Content-Type: application/pkcs10 (request), application/pkcs7-mime (response)
    - HTTP Authorization: Bearer {bootstrap_token}
    - PKCS#7 parsing: .NET SignedCms class (System.Security.Cryptography.Pkcs)

    Security:
    - Bootstrap token transmitted over HTTPS (TLS encryption)
    - Token NEVER logged in plain text (use Get-RedactedToken for logging)
    - Content-Type validation prevents protocol confusion attacks

    Acceptance Criteria:
    - Function signature includes all 4 required parameters
    - CSR converted from PEM to DER, then base64-encoded
    - HTTP POST to {PkiUrl}/.well-known/est/{ProvisionerName}/simpleenroll
    - Authorization header: Bearer {BootstrapToken}
    - Content-Type header: application/pkcs10
    - Response Content-Type validated as application/pkcs7-mime
    - PKCS#7 parsed using SignedCms.Decode()
    - Certificate extracted from Certificates[0]
    - Certificate converted to PEM format
    - Errors throw exceptions with descriptive messages
    - Logging includes enrollment start, success, and errors
    - Bootstrap token redacted in all log messages
#>
function Invoke-EstEnrollment {
    [CmdletBinding()]
    [OutputType([string])]
    param(
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]$PkiUrl,

        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]$ProvisionerName,

        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]$CsrPem,

        [Parameter(Mandatory = $false)]
        [AllowEmptyString()]
        [string]$BootstrapToken = "",

        [Parameter(Mandatory = $false)]
        [string]$BootstrapCertPath = "",

        [Parameter(Mandatory = $false)]
        [string]$BootstrapKeyPath = ""
    )

    try {
        # Construct EST endpoint URL
        # For step-ca EST implementation, include provisioner name in path
        $estEndpoint = "$PkiUrl/.well-known/est/$ProvisionerName/simpleenroll"

        # Convert CSR from PEM to DER
        $csrDer = ConvertFrom-PemToDer -PemContent $CsrPem -Label "CERTIFICATE REQUEST"

        # Base64-encode DER for HTTP transmission
        $csrBase64 = [Convert]::ToBase64String($csrDer)

        # Determine authentication method: mTLS (bootstrap cert) or Bearer token
        $useBootstrapCert = (-not [string]::IsNullOrEmpty($BootstrapCertPath)) -and (-not [string]::IsNullOrEmpty($BootstrapKeyPath))

        if ($useBootstrapCert) {
            # Verify bootstrap certificate files exist
            if (-not (Test-Path $BootstrapCertPath)) {
                throw "Bootstrap certificate not found at path: $BootstrapCertPath"
            }
            if (-not (Test-Path $BootstrapKeyPath)) {
                throw "Bootstrap private key not found at path: $BootstrapKeyPath"
            }

            # Load bootstrap certificate to get subject for logging
            $bootstrapCert = [System.Security.Cryptography.X509Certificates.X509Certificate2]::new($BootstrapCertPath)

            # Log enrollment start with mTLS
            Write-LogInfo -Message "Sending EST enrollment request with bootstrap certificate (mTLS)" -Context @{
                endpoint = $estEndpoint
                provisioner = $ProvisionerName
                bootstrapCertSubject = $bootstrapCert.Subject
                bootstrapCertExpiry = $bootstrapCert.NotAfter.ToString("yyyy-MM-ddTHH:mm:ssZ")
            }
        }
        else {
            # Get redacted token for logging
            $redactedToken = Get-RedactedToken -Token $BootstrapToken

            # Log enrollment start with bearer token
            Write-LogInfo -Message "Sending EST enrollment request with bootstrap token (Bearer)" -Context @{
                endpoint = $estEndpoint
                provisioner = $ProvisionerName
                token = $redactedToken
            }
        }

        # Make HTTP POST request with appropriate authentication
        try {
            if ($useBootstrapCert) {
                # Create temporary PFX file to combine certificate and private key for mTLS
                $pfxPath = "/tmp/bootstrap-mtls-$(Get-Random -Minimum 10000 -Maximum 99999).pfx"
                $pfxPassword = "temp-$(Get-Random -Minimum 100000 -Maximum 999999)"

                try {
                    # Use OpenSSL to create PFX from separate PEM cert + key files
                    $opensslOutput = & openssl pkcs12 -export `
                        -in $BootstrapCertPath `
                        -inkey $BootstrapKeyPath `
                        -out $pfxPath `
                        -password "pass:$pfxPassword" 2>&1

                    if ($LASTEXITCODE -ne 0) {
                        throw "OpenSSL PFX creation failed: $opensslOutput"
                    }

                    # Load PFX with private key for mTLS authentication
                    $certWithKey = [System.Security.Cryptography.X509Certificates.X509Certificate2]::new(
                        $pfxPath,
                        $pfxPassword,
                        [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::Exportable
                    )

                    Write-LogDebug -Message "Loaded bootstrap certificate with private key for mTLS" -Context @{
                        thumbprint = $certWithKey.Thumbprint
                        hasPrivateKey = $certWithKey.HasPrivateKey
                    }

                    # Make HTTP POST request with mTLS client certificate authentication
                    $httpResponse = Invoke-EstHttpRequest `
                        -Uri $estEndpoint `
                        -Method Post `
                        -Certificate $certWithKey `
                        -ContentType "application/pkcs10" `
                        -Body $csrBase64

                    $response = $httpResponse.Body
                    $responseHeaders = $httpResponse.Headers
                    $statusCode = $httpResponse.StatusCode
                }
                finally {
                    # Clean up temporary PFX file
                    if (Test-Path $pfxPath) {
                        Remove-Item $pfxPath -Force -ErrorAction SilentlyContinue
                        Write-LogDebug -Message "Cleaned up temporary bootstrap PFX file"
                    }
                }
            }
            else {
                # Use Bearer token authentication
                $httpResponse = Invoke-EstHttpRequest `
                    -Uri $estEndpoint `
                    -Method Post `
                    -Headers @{ Authorization = "Bearer $BootstrapToken" } `
                    -ContentType "application/pkcs10" `
                    -Body $csrBase64

                $response = $httpResponse.Body
                $responseHeaders = $httpResponse.Headers
                $statusCode = $httpResponse.StatusCode
            }
        }
        catch {
            # Extract error details
            $httpStatusCode = $_.Exception.Response.StatusCode.value__
            $errorBody = $_.ErrorDetails.Message

            # Handle specific error scenarios
            if ($httpStatusCode -eq 401) {
                # Invalid bootstrap token
                Write-LogError -Message "EST enrollment failed: 401 Unauthorized" -Context @{
                    status_code = 401
                    endpoint = $estEndpoint
                    token = $redactedToken
                    error = "Invalid or expired bootstrap token"
                }
                throw "EST enrollment failed: 401 Unauthorized - Invalid or expired bootstrap token"
            }
            elseif ($httpStatusCode -eq 400) {
                # Malformed CSR
                Write-LogError -Message "EST enrollment failed: 400 Bad Request" -Context @{
                    status_code = 400
                    endpoint = $estEndpoint
                    error = "Malformed CSR"
                    details = $errorBody
                }
                throw "EST enrollment failed: 400 Bad Request - Malformed CSR: $errorBody"
            }
            elseif ($httpStatusCode -eq 500) {
                # CA internal error
                Write-LogError -Message "EST enrollment failed: 500 Internal Server Error" -Context @{
                    status_code = 500
                    endpoint = $estEndpoint
                    error = "CA internal error"
                    details = $errorBody
                }
                throw "EST enrollment failed: 500 Internal Server Error - CA internal error: $errorBody"
            }
            else {
                # Network error or other HTTP error
                Write-LogError -Message "EST enrollment failed: Network error" -Context @{
                    status_code = $httpStatusCode
                    endpoint = $estEndpoint
                    error = $_.Exception.Message
                }
                throw "EST enrollment failed: $($_.Exception.Message)"
            }
        }

        # Validate response Content-Type
        # Handle both string and array values (some HTTP libraries return arrays)
        $contentType = $responseHeaders['Content-Type']
        if ($contentType -is [array]) {
            $contentType = $contentType[0]
        }
        if ($contentType -notlike '*application/pkcs7-mime*') {
            Write-LogError -Message "EST enrollment failed: Invalid response Content-Type" -Context @{
                expected = "application/pkcs7-mime"
                actual = $contentType
                endpoint = $estEndpoint
            }
            throw "EST enrollment failed: Invalid response Content-Type - expected 'application/pkcs7-mime', got '$contentType'"
        }

        # Decode base64 response to DER
        $pkcs7Der = [Convert]::FromBase64String($response)

        # Parse PKCS#7 using SignedCms
        $signedCms = [System.Security.Cryptography.Pkcs.SignedCms]::new()
        $signedCms.Decode($pkcs7Der)

        # Log certificate count for diagnostics
        $certCount = $signedCms.Certificates.Count
        Write-LogDebug -Message "PKCS#7 container contains $certCount certificate(s)"

        # Extract end-entity certificate (first certificate in collection)
        if ($certCount -eq 0) {
            throw "EST enrollment failed: PKCS#7 response contains no certificates"
        }

        $clientCertificate = $signedCms.Certificates[0]

        # Convert certificate to PEM format
        $certDer = $clientCertificate.Export('Cert')
        $certPem = ConvertTo-PemFromDer -DerBytes $certDer -Label "CERTIFICATE"

        # Log success
        Write-LogInfo -Message "Certificate received" -Context @{
            subject = $clientCertificate.Subject
            serial = $clientCertificate.SerialNumber
            not_before = $clientCertificate.NotBefore.ToString("yyyy-MM-ddTHH:mm:ssZ")
            not_after = $clientCertificate.NotAfter.ToString("yyyy-MM-ddTHH:mm:ssZ")
        }

        return $certPem
    }
    catch {
        # Re-throw exceptions (already logged in catch blocks above)
        throw
    }
}

<#
.SYNOPSIS
    Performs EST re-enrollment to renew a client certificate using existing certificate-based mTLS authentication.

.DESCRIPTION
    Implements EST protocol (RFC 7030) /simplereenroll operation for certificate renewal.
    This function:
    1. Loads existing client certificate and private key from files
    2. Creates X509Certificate2 object with private key for mTLS authentication
    3. Converts CSR from PEM format to base64-encoded DER for EST transmission
    4. Constructs HTTP POST request to EST /simplereenroll endpoint
    5. Authenticates using mTLS (mutual TLS with existing certificate)
    6. Validates response Content-Type (application/pkcs7-mime)
    7. Parses PKCS#7 response using .NET SignedCms class
    8. Extracts X.509 certificate from PKCS#7 container
    9. Converts certificate to PEM format
    10. Returns new certificate PEM string

    mTLS Setup:
    - Uses OpenSSL to create temporary PFX from PEM certificate and key files
    - Loads PFX with X509Certificate2 for mTLS authentication
    - Cleans up temporary PFX file after loading
    - Uses Invoke-RestMethod -Certificate parameter for mTLS

    Error Handling:
    - 403 Forbidden: Existing certificate expired or invalid (throws exception)
    - 400 Bad Request: Malformed CSR (throws exception with CSR details)
    - 500 Internal Server Error: CA error (throws exception)
    - Network errors: Connection timeout, DNS failure (throws exception)
    - mTLS handshake failures: Certificate validation errors (throws exception)
    - Invalid response Content-Type: Throws exception

    Logging:
    - Info: "Sending EST re-enrollment request with existing cert: {subject}" (before HTTP request)
    - Info: "New certificate received: {newSubject}" (on success)
    - Error: "EST re-enrollment failed: 403 Forbidden - client certificate invalid" (on errors)

.PARAMETER PkiUrl
    The base URL of the step-ca PKI server (e.g., "https://pki:9000").
    Must be a valid HTTPS URL.

.PARAMETER ProvisionerName
    The EST provisioner name configured in step-ca (e.g., "est-provisioner").
    This is used to construct the EST endpoint URL.

.PARAMETER CsrPem
    The Certificate Signing Request in PEM format (as generated by CryptoHelper.New-CertificateRequest).
    Must include PEM headers (-----BEGIN CERTIFICATE REQUEST-----).
    This should contain a NEW public key for key rotation best practices.

.PARAMETER ExistingCertPath
    The file path to the existing client certificate in PEM format.
    This certificate will be used for mTLS authentication.
    Must be a valid path to a readable file.

.PARAMETER ExistingKeyPath
    The file path to the existing client private key in PEM format.
    This key will be used with the certificate for mTLS authentication.
    Must be a valid path to a readable file with appropriate permissions.

.OUTPUTS
    System.String
    Returns the new issued certificate in PEM format with headers:
    -----BEGIN CERTIFICATE-----
    [Base64-encoded certificate]
    -----END CERTIFICATE-----

.EXAMPLE
    $newCertPem = Invoke-EstReenrollment `
        -PkiUrl "https://pki:9000" `
        -ProvisionerName "est-provisioner" `
        -CsrPem $csrPem `
        -ExistingCertPath "/certs/client/client.crt" `
        -ExistingKeyPath "/certs/client/client.key"

    # Returns: PEM-encoded X.509 certificate

.EXAMPLE
    try {
        # Generate new key pair for rotation
        $newRsa = New-RSAKeyPair
        $newCsrPem = New-CertificateRequest -SubjectDN "CN=client-device-001" -SubjectAlternativeNames @() -RsaKey $newRsa

        # Perform re-enrollment with existing certificate for mTLS
        $newCertPem = Invoke-EstReenrollment `
            -PkiUrl $env:PKI_URL `
            -ProvisionerName $env:EST_PROVISIONER `
            -CsrPem $newCsrPem `
            -ExistingCertPath "/certs/client/client.crt" `
            -ExistingKeyPath "/certs/client/client.key"

        # Replace old certificate with new one
        Set-Content -Path "/certs/client/client.crt" -Value $newCertPem
        Set-Content -Path "/certs/client/client.key" -Value (ConvertTo-PemFromRsa $newRsa)
    }
    catch {
        Write-LogError -Message "Re-enrollment failed" -Context @{
            error = $_.Exception.Message
        }

        # If certificate expired (403), trigger initial enrollment recovery
        if ($_.Exception.Message -like "*403*") {
            Write-LogWarn -Message "Certificate expired, deleting for initial enrollment recovery"
            Remove-Item "/certs/client/client.crt" -Force -ErrorAction SilentlyContinue
            Remove-Item "/certs/client/client.key" -Force -ErrorAction SilentlyContinue
        }
    }

.NOTES
    Protocol Compliance:
    - CSR encoding: PEM -> DER -> Base64 (no PEM headers in HTTP body)
    - HTTP Content-Type: application/pkcs10 (request), application/pkcs7-mime (response)
    - mTLS Authentication: Client certificate and key loaded via X509Certificate2 with private key
    - PKCS#7 parsing: .NET SignedCms class (System.Security.Cryptography.Pkcs)

    Security:
    - Client certificate transmitted via TLS layer (mTLS handshake)
    - Private key never transmitted over network
    - Temporary PFX file created with random password and deleted after loading
    - Content-Type validation prevents protocol confusion attacks

    mTLS Implementation:
    - Uses OpenSSL to create temporary PFX from separate PEM cert + key files
    - X509Certificate2 requires private key to be attached for mTLS
    - Temporary PFX file cleaned up to prevent credential leakage
    - Random password used for PFX to enhance security

    Certificate Validation (Optional Pre-check):
    - Function can optionally check if existing certificate is expired before mTLS attempt
    - This provides better error messages and avoids unnecessary network calls
    - However, pre-check is not required per acceptance criteria

    Acceptance Criteria:
    - Function signature includes all 5 required parameters
    - CSR converted from PEM to DER, then base64-encoded (same as initial enrollment)
    - mTLS configuration: loads existing certificate and key from files
    - Creates X509Certificate2 object with private key attached
    - HTTP POST to {PkiUrl}/.well-known/est/{ProvisionerName}/simplereenroll
    - Content-Type header: application/pkcs10
    - Uses Invoke-RestMethod -Certificate parameter for mTLS
    - Response Content-Type validated as application/pkcs7-mime
    - PKCS#7 parsed using SignedCms.Decode() (identical to initial enrollment)
    - Certificate extracted from Certificates[0]
    - Certificate converted to PEM format
    - Error handling for 403 (invalid/expired cert), 400 (malformed CSR), 500 (CA error)
    - Logging includes re-enrollment start, success, and errors
#>
function Invoke-EstReenrollment {
    [CmdletBinding()]
    [OutputType([string])]
    param(
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]$PkiUrl,

        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]$ProvisionerName,

        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]$CsrPem,

        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]$ExistingCertPath,

        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]$ExistingKeyPath
    )

    try {
        # Construct EST re-enrollment endpoint URL
        # For step-ca EST implementation, include provisioner name in path
        $estEndpoint = "$PkiUrl/.well-known/est/$ProvisionerName/simplereenroll"

        # Convert CSR from PEM to DER (same logic as initial enrollment)
        $csrDer = ConvertFrom-PemToDer -PemContent $CsrPem -Label "CERTIFICATE REQUEST"

        # Base64-encode DER for HTTP transmission
        $csrBase64 = [Convert]::ToBase64String($csrDer)

        # Load existing certificate to get subject for logging
        $existingCert = [System.Security.Cryptography.X509Certificates.X509Certificate2]::new($ExistingCertPath)

        # Log re-enrollment start
        Write-LogInfo -Message "Sending EST re-enrollment request with existing cert" -Context @{
            endpoint = $estEndpoint
            provisioner = $ProvisionerName
            existingCertSubject = $existingCert.Subject
            existingCertExpiry = $existingCert.NotAfter.ToString("yyyy-MM-ddTHH:mm:ssZ")
        }

        # Create temporary PFX file to combine certificate and private key for mTLS
        # This is necessary because X509Certificate2 requires the private key to be attached
        $pfxPath = "/tmp/client-mtls-$(Get-Random -Minimum 10000 -Maximum 99999).pfx"
        $pfxPassword = "temp-$(Get-Random -Minimum 100000 -Maximum 999999)"

        try {
            # Use OpenSSL to create PFX from separate PEM cert + key files
            $opensslOutput = & openssl pkcs12 -export `
                -in $ExistingCertPath `
                -inkey $ExistingKeyPath `
                -out $pfxPath `
                -password "pass:$pfxPassword" 2>&1

            if ($LASTEXITCODE -ne 0) {
                throw "OpenSSL PFX creation failed: $opensslOutput"
            }

            # Load PFX with private key for mTLS authentication
            $certWithKey = [System.Security.Cryptography.X509Certificates.X509Certificate2]::new(
                $pfxPath,
                $pfxPassword,
                [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::Exportable
            )

            Write-LogDebug -Message "Loaded certificate with private key for mTLS" -Context @{
                thumbprint = $certWithKey.Thumbprint
                hasPrivateKey = $certWithKey.HasPrivateKey
            }

            # Make HTTP POST request with mTLS client certificate authentication using wrapper
            try {
                $httpResponse = Invoke-EstHttpRequest `
                    -Uri $estEndpoint `
                    -Method Post `
                    -Certificate $certWithKey `
                    -ContentType "application/pkcs10" `
                    -Body $csrBase64

                $response = $httpResponse.Body
                $responseHeaders = $httpResponse.Headers
                $statusCode = $httpResponse.StatusCode
            }
            catch {
                # Extract error details
                $httpStatusCode = $_.Exception.Response.StatusCode.value__
                $errorBody = $_.ErrorDetails.Message

                # Handle specific error scenarios
                if ($httpStatusCode -eq 403) {
                    # Invalid or expired client certificate
                    Write-LogError -Message "EST re-enrollment failed: 403 Forbidden" -Context @{
                        status_code = 403
                        endpoint = $estEndpoint
                        existingCertSubject = $existingCert.Subject
                        existingCertExpiry = $existingCert.NotAfter.ToString("yyyy-MM-ddTHH:mm:ssZ")
                        error = "Client certificate invalid or expired"
                        details = $errorBody
                    }
                    throw "EST re-enrollment failed: 403 Forbidden - client certificate invalid or expired"
                }
                elseif ($httpStatusCode -eq 400) {
                    # Malformed CSR
                    Write-LogError -Message "EST re-enrollment failed: 400 Bad Request" -Context @{
                        status_code = 400
                        endpoint = $estEndpoint
                        error = "Malformed CSR"
                        details = $errorBody
                    }
                    throw "EST re-enrollment failed: 400 Bad Request - Malformed CSR: $errorBody"
                }
                elseif ($httpStatusCode -eq 500) {
                    # CA internal error
                    Write-LogError -Message "EST re-enrollment failed: 500 Internal Server Error" -Context @{
                        status_code = 500
                        endpoint = $estEndpoint
                        error = "CA internal error"
                        details = $errorBody
                    }
                    throw "EST re-enrollment failed: 500 Internal Server Error - CA internal error: $errorBody"
                }
                else {
                    # Network error, mTLS handshake failure, or other HTTP error
                    Write-LogError -Message "EST re-enrollment failed: Network or TLS error" -Context @{
                        status_code = $httpStatusCode
                        endpoint = $estEndpoint
                        error = $_.Exception.Message
                    }
                    throw "EST re-enrollment failed: $($_.Exception.Message)"
                }
            }

            # Validate response Content-Type
            # Handle both string and array values (some HTTP libraries return arrays)
            $contentType = $responseHeaders['Content-Type']
            if ($contentType -is [array]) {
                $contentType = $contentType[0]
            }
            if ($contentType -notlike '*application/pkcs7-mime*') {
                Write-LogError -Message "EST re-enrollment failed: Invalid response Content-Type" -Context @{
                    expected = "application/pkcs7-mime"
                    actual = $contentType
                    endpoint = $estEndpoint
                }
                throw "EST re-enrollment failed: Invalid response Content-Type - expected 'application/pkcs7-mime', got '$contentType'"
            }

            # Decode base64 response to DER (identical to initial enrollment)
            $pkcs7Der = [Convert]::FromBase64String($response)

            # Parse PKCS#7 using SignedCms (identical to initial enrollment)
            $signedCms = [System.Security.Cryptography.Pkcs.SignedCms]::new()
            $signedCms.Decode($pkcs7Der)

            # Log certificate count for diagnostics
            $certCount = $signedCms.Certificates.Count
            Write-LogDebug -Message "PKCS#7 container contains $certCount certificate(s)"

            # Extract end-entity certificate (first certificate in collection)
            if ($certCount -eq 0) {
                throw "EST re-enrollment failed: PKCS#7 response contains no certificates"
            }

            $newCertificate = $signedCms.Certificates[0]

            # Convert certificate to PEM format
            $certDer = $newCertificate.Export('Cert')
            $certPem = ConvertTo-PemFromDer -DerBytes $certDer -Label "CERTIFICATE"

            # Log success
            Write-LogInfo -Message "New certificate received" -Context @{
                subject = $newCertificate.Subject
                serial = $newCertificate.SerialNumber
                not_before = $newCertificate.NotBefore.ToString("yyyy-MM-ddTHH:mm:ssZ")
                not_after = $newCertificate.NotAfter.ToString("yyyy-MM-ddTHH:mm:ssZ")
                oldCertExpiry = $existingCert.NotAfter.ToString("yyyy-MM-ddTHH:mm:ssZ")
            }

            return $certPem
        }
        finally {
            # Clean up temporary PFX file to prevent credential leakage
            if (Test-Path $pfxPath) {
                Remove-Item $pfxPath -Force -ErrorAction SilentlyContinue
                Write-LogDebug -Message "Cleaned up temporary PFX file"
            }
        }
    }
    catch {
        # Re-throw exceptions (already logged in catch blocks above)
        throw
    }
}

# ============================================================================
# MODULE EXPORTS
# ============================================================================

# Export public functions (internal helpers remain private)
Export-ModuleMember -Function Invoke-EstEnrollment, Invoke-EstReenrollment
