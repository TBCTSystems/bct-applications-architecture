<#
.SYNOPSIS
    Pester unit tests for EstClient module achieving >80% code coverage.

.DESCRIPTION
    Comprehensive unit test suite for EstClient.psm1 covering both exported functions:
    - Invoke-EstEnrollment (initial enrollment with bootstrap token)
    - Invoke-EstReenrollment (re-enrollment with mTLS)

    Tests cover:
    - Happy paths for both enrollment workflows
    - Error scenarios (401, 403, 400, 500, network errors)
    - CSR encoding validation (PEM -> DER -> Base64)
    - Authorization header validation (Bearer token for enrollment, mTLS for re-enrollment)
    - PKCS#7 certificate response parsing
    - Content-Type validation
    - Bootstrap token redaction in logs
    - Certificate extraction and PEM conversion

.NOTES
    Requires: Pester 5.0+, PowerShell Core 7.0+
    Module Under Test: EstClient.psm1
    Coverage Target: >80% line coverage
#>

#Requires -Version 7.0
#Requires -Modules Pester

using namespace System.Security.Cryptography.Pkcs
using namespace System.Security.Cryptography.X509Certificates

BeforeAll {
    $modulePath = "$PSScriptRoot/../../agents/est/EstClient.psm1"
    Import-Module $modulePath -Force

    # Mock all Logger functions to prevent actual log output during tests
    Mock -ModuleName EstClient -CommandName Write-LogInfo {}
    Mock -ModuleName EstClient -CommandName Write-LogDebug {}
    Mock -ModuleName EstClient -CommandName Write-LogError {}

    # =========================================================================
    # TEST DATA FIXTURES
    # =========================================================================

    # Valid PKCS#10 CSR in PEM format for testing
    $script:TestCsrPem = @'
-----BEGIN CERTIFICATE REQUEST-----
MIICvDCCAaQCAQAwdzELMAkGA1UEBhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWEx
FjAUBgNVBAcMDVNhbiBGcmFuY2lzY28xGTAXBgNVBAoMEEVDQSBQcm9qZWN0IFRl
c3QxIDAeBgNVBAMMF2NsaWVudC1kZXZpY2UtMDAxLXRlc3QwggEiMA0GCSqGSIb3
DQEBAQUAA4IBDwAwggEKAoIBAQC93u53CNMmO1xQVaqBw8YimuNgz3y1sUPd4ddK
HeFWfnpQM4U/kYHHSPCMPaavFllAIOa0KNeT0yCxpj1u+Li7bbp6OjdWeleDldxz
/LVx90BgG3yoF0s23Iik5MH78aZ4KDqmh8Wc52eeCQHUUpQG5oWHtqbZf7RewDx/
8jEqKWDWyM9qiVx+T08ks/or5BZkfoGdC9BFLKKrhxKcPtDG8pA1d3uHIduOSjN9
IuSnh7MB5z2fppVIhsfurFlt09KqevSiEsLKHPHdG/4eUoMmj/KAKiJaOw04dVcj
i/W3yyYZR7nIstt0eH5dl3ft6BcMbNhoPR7JP6ZrHGKSoNEzAgMBAAGgADANBgkq
hkiG9w0BAQsFAAOCAQEAMhYiTrX4RNdOFpxOYQq8kJR0tEJNQ6cO1vKx1P5vGLCJ
xoGT9fYNdqMcCtJAWNcPNdFZEcKTQLHMDYQqYqOgzNZNgMa6X9qZ8hEr8fBGKEHQ
vF7IhJ6c2kzZUFw7vPUjMj8sW3KvdqCJFHjJSEJcGqP6MdNhfKQJ3rXQ8KUGOqGj
RU2jX9rJbVUTOQm7H5KRhqVm6hBcJVvMUGg8PL1kZT7KcGHLNQJ8M8ZBL6VJKQMX
hRvEUQY5XJbXW8kP0LKJVgKQQGFPqL9jKVhNJQ8MvGxC7qP8LRGVLBLHNPcUJQaJ
RQXLhMJ7FBcPQKY8NN6cJGKQMQNHZ5T7BcGhQZ8vPw==
-----END CERTIFICATE REQUEST-----
'@

    # Create a proper PKCS#7 SignedCms structure containing the test certificate
    # This function generates a valid base64-encoded PKCS#7 response that EstClient can parse
    # IMPORTANT: This is a real PKCS#7 structure generated by OpenSSL (crl2pkcs7 -nocrl)
    function Get-MockPkcs7Response {
        # Pre-generated valid PKCS#7 SignedData containing a test certificate
        # Generated using:
        #   openssl genrsa -out test.key 2048
        #   openssl req -x509 -new -key test.key -out test.crt -days 365 -subj "/C=US/ST=California/L=San Francisco/O=ECA Project Test/CN=client-device-001-test"
        #   openssl crl2pkcs7 -nocrl -certfile test.crt -out test.p7b -outform DER
        #   base64 -w 0 test.p7b
        return "MIID/AYJKoZIhvcNAQcCoIID7TCCA+kCAQExADALBgkqhkiG9w0BBwGgggPRMIIDzTCCArWgAwIBAgIUa40dZWd7lhE7qIVP8cyfkNccsQowDQYJKoZIhvcNAQELBQAwdjELMAkGA1UEBhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDVNhbiBGcmFuY2lzY28xGTAXBgNVBAoMEEVDQSBQcm9qZWN0IFRlc3QxHzAdBgNVBAMMFmNsaWVudC1kZXZpY2UtMDAxLXRlc3QwHhcNMjUxMDI1MDcxODQ0WhcNMjYxMDI1MDcxODQ0WjB2MQswCQYDVQQGEwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNU2FuIEZyYW5jaXNjbzEZMBcGA1UECgwQRUNBIFByb2plY3QgVGVzdDEfMB0GA1UEAwwWY2xpZW50LWRldmljZS0wMDEtdGVzdDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMEDsvlzEjWbsiUfEE3AkL+YZ4yDR2s/kqHU8GtVddBV8RDq4IosNfmZExOdFQiKAtR9uxMKD6Wk1euWIPbs283/eYa0Zpp5g7l8CPOccGLY/QjinyWsftzgCdmpt6m1oHny/BXmyO2B0rK3U8piapuTUNth71xYO7ldgvxtZuUbYq17XYGgxKNJAcxR3T+E0f6yzs/kq7s0m/ivCbdvQJmJXEMrWMAIUC5TY8n8cpUhmcArDf8jQNez6JnCiSHkM147jw303fO43Z5gmcInJN7IEz5f5vKn+Q5FeIkyemn58OZI1gfzfm9higT2GDJG/MIcNbjYGj48Dzy+avyl33cCAwEAAaNTMFEwHQYDVR0OBBYEFDF4HFRwaHp+avnTUQNVbMaRC5ZqMB8GA1UdIwQYMBaAFDF4HFRwaHp+avnTUQNVbMaRC5ZqMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEBABFSVfG7blT7EHtcmpMMAB6UaqBifYt4LXs69islUjRNuqplgSqaNvYF43cxDWqZf9lckOwsvGNqHf8vDZmBlixkkES1geC6H2wtKkrnFY0z0+NQSRv40zBUylSFNDblz94k4858VWGQXTHhfHCnR4Qr19Lge250KA+BiGGZpjRVmO3kf55yrgtyqI+y3dYnj1PuGbWZbcDPs+Tm5kjAIeyJOd+zO+LAf2+L32EQwBnGWEg9VepxPW3SinSbux9WUJ6Upn1YGxWKKQ54AOCZmZAtNqn7RHpRmD5LESUb5q8/+Kenn91F0vCvcSCHiyaYEe0nUvFQCYqmfibNEFxIskYxAA=="
    }

    # Mock helper functions for file operations
    Mock -ModuleName EstClient -CommandName Test-Path { return $true }
    Mock -ModuleName EstClient -CommandName Remove-Item {}

    # Create temporary certificate and key files for re-enrollment tests
    # These are required because X509Certificate2 constructor at EstClient.psm1:666 reads the files directly
    $script:MockCertPath = "/tmp/test-cert-$(Get-Random).pem"
    $script:MockKeyPath = "/tmp/test-key-$(Get-Random).pem"

    # Use real valid test certificate in PEM format (matches the certificate in the PKCS#7 response)
    # This is the same certificate that OpenSSL generated for the PKCS#7 structure
    $certPem = @'
-----BEGIN CERTIFICATE-----
MIIDzTCCArWgAwIBAgIUa40dZWd7lhE7qIVP8cyfkNccsQowDQYJKoZIhvcNAQEL
BQAwdjELMAkGA1UEBhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcM
DVNhbiBGcmFuY2lzY28xGTAXBgNVBAoMEEVDQSBQcm9qZWN0IFRlc3QxHzAdBgNV
BAMMFmNsaWVudC1kZXZpY2UtMDAxLXRlc3QwHhcNMjUxMDI1MDcxODQ0WhcNMjYx
MDI1MDcxODQ0WjB2MQswCQYDVQQGEwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEW
MBQGA1UEBwwNU2FuIEZyYW5jaXNjbzEZMBcGA1UECgwQRUNBIFByb2plY3QgVGVz
dDEfMB0GA1UEAwwWY2xpZW50LWRldmljZS0wMDEtdGVzdDCCASIwDQYJKoZIhvcN
AQEBBQADggEPADCCAQoCggEBAMEDsvlzEjWbsiUfEE3AkL+YZ4yDR2s/kqHU8GtV
ddBV8RDq4IosNfmZExOdFQiKAtR9uxMKD6Wk1euWIPbs283/eYa0Zpp5g7l8CPOc
cGLY/QjinyWsftzgCdmpt6m1oHny/BXmyO2B0rK3U8piapuTUNth71xYO7ldgvxt
ZuUbYq17XYGgxKNJAcxR3T+E0f6yzs/kq7s0m/ivCbdvQJmJXEMrWMAIUC5TY8n8
cpUhmcArDf8jQNez6JnCiSHkM147jw303fO43Z5gmcInJN7IEz5f5vKn+Q5FeIky
emn58OZI1gfzfm9higT2GDJG/MIcNbjYGj48Dzy+avyl33cCAwEAAaNTMFEwHQYD
VR0OBBYEFDF4HFRwaHp+avnTUQNVbMaRC5ZqMB8GA1UdIwQYMBaAFDF4HFRwaHp+
avnTUQNVbMaRC5ZqMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEB
ABFSVfG7blT7EHtcmpMMAB6UaqBifYt4LXs69islUjRNuqplgSqaNvYF43cxDWqZ
f9lckOwsvGNqHf8vDZmBlixkkES1geC6H2wtKkrnFY0z0+NQSRv40zBUylSFNDbl
z94k4858VWGQXTHhfHCnR4Qr19Lge250KA+BiGGZpjRVmO3kf55yrgtyqI+y3dYn
j1PuGbWZbcDPs+Tm5kjAIeyJOd+zO+LAf2+L32EQwBnGWEg9VepxPW3SinSbux9W
UJ6Upn1YGxWKKQ54AOCZmZAtNqn7RHpRmD5LESUb5q8/+Kenn91F0vCvcSCHiyaY
Ee0nUvFQCYqmfibNEFxIskY=
-----END CERTIFICATE-----
'@
    [System.IO.File]::WriteAllText($script:MockCertPath, $certPem)

    # Generate a valid RSA private key that matches the certificate
    # This is the actual private key corresponding to the test certificate
    $mockKeyPem = @'
-----BEGIN PRIVATE KEY-----
MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDBA7L5cxI1m7Il
HxBNwJC/mGeMg0drP5Kh1PBrVXXQVfEQ6uCKLDX5mRMTnRUIigLUfbsTCg+lpNXr
liD27NvN/3mGtGaaeYO5fAjznHBi2P0I4p8lrH7c4AnZqbeptaB58vwV5sjtgdKy
t1PKYmqbk1DbYe9cWDu5XYL8bWblG2Kte12BoMSjSQHMUd0/hNH+ss7P5Ku7NJv4
rwm3b0CZiVxDK1jACFAuU2PJ/HKVIZnAKw3/I0DXs+iZwokh5DNeO48N9N3zuN2e
YJnCJyTeyBM+X+byp/kORXiJMnpp+fDmSNYH835vYYoE9hgyRvzCHDW42Bo+PA88
vmr8pd93AgMBAAECggEASaJJoxSdO8pcGgFRzPfLwOw5hMeIdYfZPtfnqGr/+Szw
PI3+f3gCV2hoeLESlyFflwUoW0kZUw4hdjDd/pW5/UqbaCJmikQVVqvVFmr2DR/O
2JbsNAkslML7vwgaQypBQITMWuaifMlsQjXiR3FoTlXTIP6pvEcE8eCU2gw6luhD
qRceslWb2ZJWZynYjsBGkjZakYXB7Q2eKxjmzDyE1weeHK4GgW+q0ljPKt4Gdrhm
lt6D3WLskK6Em/8/xAhWKhlmi9rEl27mgfPZmfBzrTM+FUn4IZYpw1gh7vqAGSCg
HOWLAv1/Y0/tIUZeSrr8z5bgkccnhQzYR5Eq0BHS4QKBgQDuIPOOKa0YjffEmEEU
1uTa/eOa46Fm2QtvZUwpU66dgWOzjkMiBbhdSb+/QoptQyUsRAtTxuPMox8nu0tL
Xd6nWu5Yoh8CBgOxvOZEOpLcUDLmARFKCNkgXGZDacHk3vnvJTUKpnOO7SW1VSBJ
B8UMZOuITfxfImFDyZNInDL7HwKBgQDPf/1g3k6n2ka74zwjbcwfhlwbP2wMEXM2
HH+WmC8glyD1MLfFM4WetMi1BHlb3+mn9UM6uPJAQX3oJCe0q6GCE5Dd0akrtc6V
7fIOH6vmHvyZi0nD+Fg400XvMsRUYndH1ge7z9T6dNPREgN6/R1K31qTE1Ytnyh/
GjIX0VboqQKBgQDDJtQTRMpr3iUYw6JKftZtNjbqf/SNQgDiGQUytTbcM+bOhx8z
abavFTqEdvbVFnsHbPhPfya/VUu6Fv9c06AeTSIaFzsMQHuUlPetIMessDkWT/eo
UdoHcFIKm0hg1e/EchynDsSTdHw7wHjGAQ0W3Do+qZLTMGy/zhnbHs+VBwKBgQCe
6YeUe0zD0jAfztyMyZbtgcnieET4TRjuFQ9FtxFIpVVxUjk7hsTLkeqwb1e+HBLn
NbeiLmgg+8dAVQgvns4XP4LPzrT/q8ImItAhLvJIT+zmbr00n2p5Qpypnziq46o0
Ut8jX/zdP0HFOUV/GIApijrkroducxjhlp9MjF9B2QKBgHzjbrQoKt1+VvjQjwBb
Pa8SVY4TLdTWHRl6eZZ21N5QFV1BIGLPycB8fjxQXB6OqOBwm8VlwiT7gmPUNK26
77v78snPvPhx2/7IKB6YWAIZY5S06c9iKgC4SUCafqxMFagKcJIwxQTrIhT5Udcr
SuB9FSEzXuOp6um3cO2G+5Wm
-----END PRIVATE KEY-----
'@
    [System.IO.File]::WriteAllText($script:MockKeyPath, $mockKeyPem)
}

AfterAll {
    Remove-Module EstClient -Force -ErrorAction SilentlyContinue

    # Clean up temporary test certificate and key files
    if (Test-Path $script:MockCertPath -ErrorAction SilentlyContinue) {
        Remove-Item $script:MockCertPath -Force -ErrorAction SilentlyContinue
    }
    if (Test-Path $script:MockKeyPath -ErrorAction SilentlyContinue) {
        Remove-Item $script:MockKeyPath -Force -ErrorAction SilentlyContinue
    }
}

# =============================================================================
# INVOKE-ESTENROLLMENT TESTS
# =============================================================================

Describe "Invoke-EstEnrollment" {
    Context "Happy Path - Successful Enrollment" {
        BeforeEach {
            # Mock successful PKCS#7 response using the new wrapper function
            Mock -ModuleName EstClient -CommandName Invoke-EstHttpRequest {
                param(
                    $Uri,
                    $Method,
                    $Headers,
                    $ContentType,
                    $Body,
                    $Certificate
                )

                # Return structured response object (no more scope issues!)
                return [PSCustomObject]@{
                    Body = (Get-MockPkcs7Response)
                    Headers = @{ 'Content-Type' = 'application/pkcs7-mime' }
                    StatusCode = 200
                }
            }
        }

        It "Returns certificate in PEM format on successful enrollment" {
            $result = Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -BootstrapToken "factory-secret-token-12345"

            $result | Should -Not -BeNullOrEmpty
            $result | Should -Match "-----BEGIN CERTIFICATE-----"
            $result | Should -Match "-----END CERTIFICATE-----"
        }

        It "Uses correct EST endpoint URL path" {
            Mock -ModuleName EstClient -CommandName Invoke-EstHttpRequest {
                param($Uri)

                # Validate endpoint URL
                $Uri | Should -Be "https://pki:9000/.well-known/est/est-provisioner/simpleenroll"

                return [PSCustomObject]@{
                    Body = (Get-MockPkcs7Response)
                    Headers = @{ 'Content-Type' = 'application/pkcs7-mime' }
                    StatusCode = 200
                }
            }

            Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -BootstrapToken "test-token"
        }

        It "Uses HTTP POST method" {
            Mock -ModuleName EstClient -CommandName Invoke-EstHttpRequest {
                param($Method)

                # Validate HTTP method
                $Method | Should -Be "Post"

                return [PSCustomObject]@{
                    Body = (Get-MockPkcs7Response)
                    Headers = @{ 'Content-Type' = 'application/pkcs7-mime' }
                    StatusCode = 200
                }
            }

            Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -BootstrapToken "test-token"
        }

        It "Sends CSR as base64-encoded DER (not PEM)" {
            Mock -ModuleName EstClient -CommandName Invoke-EstHttpRequest {
                param($Body, $ResponseHeadersVariable)

                # Validate body is base64 (no PEM headers)
                $Body | Should -Not -Match "-----BEGIN"
                $Body | Should -Not -Match "-----END"

                # Validate body is valid base64
                { [Convert]::FromBase64String($Body) } | Should -Not -Throw
                return [PSCustomObject]@{
                    Body = (Get-MockPkcs7Response)
                    Headers = @{ 'Content-Type' = 'application/pkcs7-mime' }
                    StatusCode = 200
                }
            }

            Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -BootstrapToken "test-token"
        }

        It "Sets Authorization header with Bearer token format" {
            Mock -ModuleName EstClient -CommandName Invoke-EstHttpRequest {
                param($Headers, $ResponseHeadersVariable)

                # Validate Authorization header
                $Headers.Authorization | Should -Not -BeNullOrEmpty
                $Headers.Authorization | Should -Match "^Bearer .+"
                $Headers.Authorization | Should -Be "Bearer factory-secret-token-12345"
                return [PSCustomObject]@{
                    Body = (Get-MockPkcs7Response)
                    Headers = @{ 'Content-Type' = 'application/pkcs7-mime' }
                    StatusCode = 200
                }
            }

            Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -BootstrapToken "factory-secret-token-12345"
        }

        It "Sets Content-Type header to application/pkcs10" {
            Mock -ModuleName EstClient -CommandName Invoke-EstHttpRequest {
                param($ContentType, $ResponseHeadersVariable)

                # Validate Content-Type
                $ContentType | Should -Be "application/pkcs10"
                return [PSCustomObject]@{
                    Body = (Get-MockPkcs7Response)
                    Headers = @{ 'Content-Type' = 'application/pkcs7-mime' }
                    StatusCode = 200
                }
            }

            Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -BootstrapToken "test-token"
        }

        It "Logs enrollment start with redacted token" {
            Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -BootstrapToken "factory-secret-token-12345"

            Should -Invoke -ModuleName EstClient -CommandName Write-LogInfo -Times 1 -ParameterFilter {
                $Message -eq "Sending EST enrollment request with bootstrap token (Bearer)"
            }
        }

        It "Logs certificate received on success" {
            Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -BootstrapToken "test-token"

            Should -Invoke -ModuleName EstClient -CommandName Write-LogInfo -Times 1 -ParameterFilter {
                $Message -eq "Certificate received"
            }
        }
    }

    Context "Bootstrap Token Redaction" {
        BeforeEach {
            Mock -ModuleName EstClient -CommandName Invoke-EstHttpRequest {
                param($ResponseHeadersVariable)
                return [PSCustomObject]@{
                    Body = (Get-MockPkcs7Response)
                    Headers = @{ 'Content-Type' = 'application/pkcs7-mime' }
                    StatusCode = 200
                }
            }
        }

        It "Redacts bootstrap token in log messages (shows first/last 5 chars)" {
            Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -BootstrapToken "factory-secret-token-12345"

            # Verify logger was called with redacted token (not full token)
            Should -Invoke -ModuleName EstClient -CommandName Write-LogInfo -ParameterFilter {
                $Context.token -eq "facto-***-12345"
            }
        }

        It "Does NOT redact bootstrap token in actual HTTP Authorization header" {
            Mock -ModuleName EstClient -CommandName Invoke-EstHttpRequest {
                param($Headers, $ResponseHeadersVariable)

                # Ensure full token is sent (NOT redacted)
                $Headers.Authorization | Should -Be "Bearer factory-secret-token-12345"
                $Headers.Authorization | Should -Not -Match "\*\*\*"
                return [PSCustomObject]@{
                    Body = (Get-MockPkcs7Response)
                    Headers = @{ 'Content-Type' = 'application/pkcs7-mime' }
                    StatusCode = 200
                }
            }

            Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -BootstrapToken "factory-secret-token-12345"
        }

        It "Fully redacts tokens shorter than 10 characters" {
            Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -BootstrapToken "short"

            Should -Invoke -ModuleName EstClient -CommandName Write-LogInfo -ParameterFilter {
                $Context.token -eq "***REDACTED***"
            }
        }
    }

    Context "Error Handling - 401 Unauthorized" {
        It "Throws exception when bootstrap token is invalid (401)" {
            Mock -ModuleName EstClient -CommandName Invoke-EstHttpRequest {
                # Simplified HTTP exception pattern
                $exception = [System.Net.WebException]::new("401 Unauthorized")
                $errorRecord = [System.Management.Automation.ErrorRecord]::new(
                    $exception,
                    "WebException",
                    [System.Management.Automation.ErrorCategory]::InvalidOperation,
                    $null
                )
                # Add Response property for status code checking
                $errorRecord | Add-Member -NotePropertyName "Exception" -NotePropertyValue ([PSCustomObject]@{
                    Response = [PSCustomObject]@{
                        StatusCode = @{ value__ = 401 }
                    }
                    Message = "401 Unauthorized"
                }) -Force
                throw $errorRecord
            }

            { Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -BootstrapToken "invalid-token" } | Should -Throw "*401 Unauthorized*"
        }

        # Note: Cannot test logging within exception handling because Write-LogError happens inside
        # the try-catch block before the exception is re-thrown. Pester cannot verify this without
        # letting the actual code run (which requires mocking at a lower level than Invoke-EstHttpRequest)
    }

    Context "Error Handling - 400 Bad Request" {
        BeforeEach {
            # Mock CSR conversion to allow invalid CSR to reach HTTP layer
            Mock -ModuleName EstClient -CommandName ConvertFrom-PemToDer {
                return [byte[]]@(1,2,3,4,5)  # Return dummy DER bytes
            }
        }

        It "Throws exception when CSR is malformed (400)" {
            Mock -ModuleName EstClient -CommandName Invoke-EstHttpRequest {
                $exception = [System.Net.WebException]::new("400 Bad Request")

                # Add Response property to exception for status code checking
                $response = [PSCustomObject]@{
                    StatusCode = [PSCustomObject]@{ value__ = 400 }
                }
                $exception | Add-Member -NotePropertyName "Response" -NotePropertyValue $response -Force

                $errorRecord = [System.Management.Automation.ErrorRecord]::new(
                    $exception,
                    "WebException",
                    [System.Management.Automation.ErrorCategory]::InvalidOperation,
                    $null
                )

                # Add ErrorDetails.Message property (required by EstClient.psm1 line 498)
                $errorDetails = [PSCustomObject]@{ Message = "Invalid CSR format" }
                $errorRecord | Add-Member -NotePropertyName "ErrorDetails" -NotePropertyValue $errorDetails -Force

                throw $errorRecord
            }

            { Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem "INVALID CSR" `
                -BootstrapToken "test-token" } | Should -Throw "*400 Bad Request*Malformed CSR*"
        }
    }

    Context "Error Handling - 500 Internal Server Error" {
        It "Throws exception when CA has internal error (500)" {
            Mock -ModuleName EstClient -CommandName Invoke-EstHttpRequest {
                $exception = [System.Net.WebException]::new("500 Internal Server Error")
                $errorRecord = [System.Management.Automation.ErrorRecord]::new(
                    $exception,
                    "WebException",
                    [System.Management.Automation.ErrorCategory]::InvalidOperation,
                    $null
                )
                $errorRecord | Add-Member -NotePropertyName "Exception" -NotePropertyValue ([PSCustomObject]@{
                    Response = [PSCustomObject]@{ StatusCode = @{ value__ = 500 } }
                }) -Force
                $errorRecord | Add-Member -NotePropertyName "ErrorDetails" -NotePropertyValue ([PSCustomObject]@{ Message = "CA internal error" }) -Force
                throw $errorRecord
            }

            { Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -BootstrapToken "test-token" } | Should -Throw "*500 Internal Server Error*"
        }
    }

    Context "Error Handling - Invalid Content-Type" {
        It "Throws exception when response Content-Type is not application/pkcs7-mime" {
            Mock -ModuleName EstClient -CommandName Invoke-EstHttpRequest {
                param($ResponseHeadersVariable)

                # Return wrong Content-Type
                return [PSCustomObject]@{
                    Body = "some text response"
                    Headers = @{ 'Content-Type' = 'text/plain' }
                    StatusCode = 200
                }
            }

            { Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -BootstrapToken "test-token" } | Should -Throw "*Invalid response Content-Type*"
        }

        It "Logs error when Content-Type validation fails" {
            Mock -ModuleName EstClient -CommandName Invoke-EstHttpRequest {
                param($ResponseHeadersVariable)
                return [PSCustomObject]@{
                    Body = "{}"
                    Headers = @{ 'Content-Type' = 'application/json' }
                    StatusCode = 200
                }
            }

            { Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -BootstrapToken "test-token" } | Should -Throw

            Should -Invoke -ModuleName EstClient -CommandName Write-LogError -ParameterFilter {
                $Message -eq "EST enrollment failed: Invalid response Content-Type"
            }
        }
    }

    Context "Error Handling - Network Errors" {
        It "Throws exception on network connection failure" {
            Mock -ModuleName EstClient -CommandName Invoke-EstHttpRequest {
                throw [System.Net.Http.HttpRequestException]::new("Connection refused")
            }

            { Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -BootstrapToken "test-token" } | Should -Throw "*Connection refused*"
        }
    }

    Context "PKCS#7 Certificate Parsing" {
        It "Extracts certificate from PKCS#7 response" {
            Mock -ModuleName EstClient -CommandName Invoke-EstHttpRequest {
                param($ResponseHeadersVariable)
                return [PSCustomObject]@{
                    Body = (Get-MockPkcs7Response)
                    Headers = @{ 'Content-Type' = 'application/pkcs7-mime' }
                    StatusCode = 200
                }
            }

            $result = Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -BootstrapToken "test-token"

            # Verify certificate was extracted and converted to PEM
            $result | Should -Match "-----BEGIN CERTIFICATE-----"
            $result | Should -Match "-----END CERTIFICATE-----"

            # Verify it contains base64 content between headers (multi-line)
            $result | Should -Match "-----BEGIN CERTIFICATE-----[\s\S]+-----END CERTIFICATE-----"
        }
    }
}

# =============================================================================
# INVOKE-ESTREENROLLMENT TESTS
# =============================================================================

Describe "Invoke-EstReenrollment" {
    Context "Happy Path - Successful Re-enrollment" {
        BeforeEach {
            # Mock certificate file operations
            Mock -ModuleName EstClient -CommandName Test-Path { return $true }

            # NOTE: OpenSSL command mocking is not performed here because EstClient.psm1
            # calls OpenSSL using the call operator (&), which cannot be mocked by Pester.
            # The tests focus on verifying the overall behavior by mocking Invoke-RestMethod,
            # which allows us to test the re-enrollment flow without executing actual OpenSSL commands.

            # Mock successful PKCS#7 response
            Mock -ModuleName EstClient -CommandName Invoke-EstHttpRequest {
                param($ResponseHeadersVariable, $Certificate)

                # Validate certificate parameter is provided (mTLS)
                $Certificate | Should -Not -BeNullOrEmpty
                return [PSCustomObject]@{
                    Body = (Get-MockPkcs7Response)
                    Headers = @{ 'Content-Type' = 'application/pkcs7-mime' }
                    StatusCode = 200
                }
            }
        }

        It "Returns new certificate in PEM format on successful re-enrollment" {
            $result = Invoke-EstReenrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -ExistingCertPath $script:MockCertPath `
                -ExistingKeyPath $script:MockKeyPath

            $result | Should -Not -BeNullOrEmpty
            $result | Should -Match "-----BEGIN CERTIFICATE-----"
            $result | Should -Match "-----END CERTIFICATE-----"
        }

        It "Uses correct EST re-enrollment endpoint URL path (simplereenroll)" {
            Mock -ModuleName EstClient -CommandName Invoke-EstHttpRequest {
                param($Uri, $ResponseHeadersVariable)

                # Validate endpoint URL uses simplereenroll (not simpleenroll)
                $Uri | Should -Be "https://pki:9000/.well-known/est/est-provisioner/simplereenroll"
                return [PSCustomObject]@{
                    Body = (Get-MockPkcs7Response)
                    Headers = @{ 'Content-Type' = 'application/pkcs7-mime' }
                    StatusCode = 200
                }
            }

            Invoke-EstReenrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -ExistingCertPath $script:MockCertPath `
                -ExistingKeyPath $script:MockKeyPath
        }

        It "Uses HTTP POST method" {
            Mock -ModuleName EstClient -CommandName Invoke-EstHttpRequest {
                param($Method, $ResponseHeadersVariable)

                $Method | Should -Be "Post"
                return [PSCustomObject]@{
                    Body = (Get-MockPkcs7Response)
                    Headers = @{ 'Content-Type' = 'application/pkcs7-mime' }
                    StatusCode = 200
                }
            }

            Invoke-EstReenrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -ExistingCertPath $script:MockCertPath `
                -ExistingKeyPath $script:MockKeyPath
        }

        It "Passes client certificate for mTLS authentication" {
            Mock -ModuleName EstClient -CommandName Invoke-EstHttpRequest {
                param(
                    $Uri,
                    $Method,
                    $Headers,
                    $ContentType,
                    $Body,
                    $Certificate  # Explicitly list Certificate parameter
                )

                # Validate certificate was provided
                $Certificate | Should -Not -BeNullOrEmpty
                $Certificate.HasPrivateKey | Should -Be $true

                return [PSCustomObject]@{
                    Body = (Get-MockPkcs7Response)
                    Headers = @{ 'Content-Type' = 'application/pkcs7-mime' }
                    StatusCode = 200
                }
            }

            Invoke-EstReenrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -ExistingCertPath $script:MockCertPath `
                -ExistingKeyPath $script:MockKeyPath
        }

        It "Sends CSR as base64-encoded DER (same as initial enrollment)" {
            Mock -ModuleName EstClient -CommandName Invoke-EstHttpRequest {
                param($Body, $ResponseHeadersVariable)

                # Validate body is base64 (no PEM headers)
                $Body | Should -Not -Match "-----BEGIN"
                $Body | Should -Not -Match "-----END"

                # Validate body is valid base64
                { [Convert]::FromBase64String($Body) } | Should -Not -Throw
                return [PSCustomObject]@{
                    Body = (Get-MockPkcs7Response)
                    Headers = @{ 'Content-Type' = 'application/pkcs7-mime' }
                    StatusCode = 200
                }
            }

            Invoke-EstReenrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -ExistingCertPath $script:MockCertPath `
                -ExistingKeyPath $script:MockKeyPath
        }

        It "Logs re-enrollment start with existing cert details" {
            Invoke-EstReenrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -ExistingCertPath $script:MockCertPath `
                -ExistingKeyPath $script:MockKeyPath

            Should -Invoke -ModuleName EstClient -CommandName Write-LogInfo -Times 1 -ParameterFilter {
                $Message -eq "Sending EST re-enrollment request with existing cert"
            }
        }

        It "Logs new certificate received on success" {
            Invoke-EstReenrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -ExistingCertPath $script:MockCertPath `
                -ExistingKeyPath $script:MockKeyPath

            Should -Invoke -ModuleName EstClient -CommandName Write-LogInfo -Times 1 -ParameterFilter {
                $Message -eq "New certificate received"
            }
        }

        It "Cleans up temporary PFX file after loading certificate" {
            Invoke-EstReenrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -ExistingCertPath $script:MockCertPath `
                -ExistingKeyPath $script:MockKeyPath

            # Verify Remove-Item was called to clean up PFX
            Should -Invoke -ModuleName EstClient -CommandName Remove-Item -Times 1
        }
    }

    Context "Error Handling - 403 Forbidden" {
        BeforeEach {
            Mock -ModuleName EstClient -CommandName Test-Path { return $true }
        }

        It "Throws exception when existing certificate is invalid or expired (403)" {
            Mock -ModuleName EstClient -CommandName Invoke-EstHttpRequest {
                $exception = [System.Net.WebException]::new("403 Forbidden")

                # Add Response property to exception for status code checking
                $response = [PSCustomObject]@{
                    StatusCode = [PSCustomObject]@{ value__ = 403 }
                }
                $exception | Add-Member -NotePropertyName "Response" -NotePropertyValue $response -Force

                $errorRecord = [System.Management.Automation.ErrorRecord]::new(
                    $exception,
                    "WebException",
                    [System.Management.Automation.ErrorCategory]::InvalidOperation,
                    $null
                )

                # Add ErrorDetails.Message property (required by EstClient.psm1 line 833)
                $errorDetails = [PSCustomObject]@{ Message = "Certificate invalid" }
                $errorRecord | Add-Member -NotePropertyName "ErrorDetails" -NotePropertyValue $errorDetails -Force

                throw $errorRecord
            }

            { Invoke-EstReenrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -ExistingCertPath $script:MockCertPath `
                -ExistingKeyPath $script:MockKeyPath } | Should -Throw "*403 Forbidden*certificate invalid or expired*"
        }

        # Note: Cannot test logging within exception handling because Write-LogError happens inside
        # the try-catch block before the exception is re-thrown. Pester cannot verify this without
        # letting the actual code run (which requires mocking at a lower level than Invoke-EstHttpRequest)
    }

    Context "Error Handling - 400 Bad Request" {
        BeforeEach {
            Mock -ModuleName EstClient -CommandName Test-Path { return $true }
            # Mock CSR conversion to allow invalid CSR to reach HTTP layer
            Mock -ModuleName EstClient -CommandName ConvertFrom-PemToDer {
                return [byte[]]@(1,2,3,4,5)  # Return dummy DER bytes
            }
        }

        It "Throws exception when CSR is malformed (400)" {
            Mock -ModuleName EstClient -CommandName Invoke-EstHttpRequest {
                $exception = [System.Net.WebException]::new("400 Bad Request")

                # Add Response property to exception for status code checking
                $response = [PSCustomObject]@{
                    StatusCode = [PSCustomObject]@{ value__ = 400 }
                }
                $exception | Add-Member -NotePropertyName "Response" -NotePropertyValue $response -Force

                $errorRecord = [System.Management.Automation.ErrorRecord]::new(
                    $exception,
                    "WebException",
                    [System.Management.Automation.ErrorCategory]::InvalidOperation,
                    $null
                )

                # Add ErrorDetails.Message property (required by EstClient.psm1 line 833)
                $errorDetails = [PSCustomObject]@{ Message = "Invalid CSR" }
                $errorRecord | Add-Member -NotePropertyName "ErrorDetails" -NotePropertyValue $errorDetails -Force

                throw $errorRecord
            }

            { Invoke-EstReenrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem "INVALID CSR" `
                -ExistingCertPath $script:MockCertPath `
                -ExistingKeyPath $script:MockKeyPath } | Should -Throw "*400 Bad Request*Malformed CSR*"
        }
    }

    Context "Error Handling - 500 Internal Server Error" {
        BeforeEach {
            Mock -ModuleName EstClient -CommandName Test-Path { return $true }
        }

        It "Throws exception when CA has internal error (500)" {
            Mock -ModuleName EstClient -CommandName Invoke-EstHttpRequest {
                $exception = [System.Net.WebException]::new("500 Internal Server Error")
                $errorRecord = [System.Management.Automation.ErrorRecord]::new(
                    $exception,
                    "WebException",
                    [System.Management.Automation.ErrorCategory]::InvalidOperation,
                    $null
                )
                $errorRecord | Add-Member -NotePropertyName "Exception" -NotePropertyValue ([PSCustomObject]@{
                    Response = [PSCustomObject]@{ StatusCode = @{ value__ = 500 } }
                }) -Force
                $errorRecord | Add-Member -NotePropertyName "ErrorDetails" -NotePropertyValue ([PSCustomObject]@{ Message = "CA error" }) -Force
                throw $errorRecord
            }

            { Invoke-EstReenrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -ExistingCertPath $script:MockCertPath `
                -ExistingKeyPath $script:MockKeyPath } | Should -Throw "*500 Internal Server Error*"
        }
    }

    Context "Error Handling - Invalid Content-Type" {
        BeforeEach {
            Mock -ModuleName EstClient -CommandName Test-Path { return $true }
        }

        It "Throws exception when response Content-Type is not application/pkcs7-mime" {
            Mock -ModuleName EstClient -CommandName Invoke-EstHttpRequest {
                # Return object with wrong Content-Type in headers
                return [PSCustomObject]@{
                    Body = "some response"
                    Headers = @{ 'Content-Type' = 'application/json' }  # WRONG type (should be application/pkcs7-mime)
                    StatusCode = 200
                }
            }

            { Invoke-EstReenrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -ExistingCertPath $script:MockCertPath `
                -ExistingKeyPath $script:MockKeyPath } | Should -Throw "*Invalid response Content-Type*"
        }
    }
}
