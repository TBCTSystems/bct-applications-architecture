<#
.SYNOPSIS
    Pester unit tests for EstClient module achieving >80% code coverage.

.DESCRIPTION
    Comprehensive unit test suite for EstClient.psm1 covering both exported functions:
    - Invoke-EstEnrollment (initial enrollment with bootstrap token)
    - Invoke-EstReenrollment (re-enrollment with mTLS)

    Tests cover:
    - Happy paths for both enrollment workflows
    - Error scenarios (401, 403, 400, 500, network errors)
    - CSR encoding validation (PEM -> DER -> Base64)
    - Authorization header validation (Bearer token for enrollment, mTLS for re-enrollment)
    - PKCS#7 certificate response parsing
    - Content-Type validation
    - Bootstrap token redaction in logs
    - Certificate extraction and PEM conversion

.NOTES
    Requires: Pester 5.0+, PowerShell Core 7.0+
    Module Under Test: EstClient.psm1
    Coverage Target: >80% line coverage
#>

#Requires -Version 7.0
#Requires -Modules Pester

using namespace System.Security.Cryptography.Pkcs
using namespace System.Security.Cryptography.X509Certificates

BeforeAll {
    $modulePath = "$PSScriptRoot/../../agents/est/EstClient.psm1"
    Import-Module $modulePath -Force

    # Mock all Logger functions to prevent actual log output during tests
    Mock -ModuleName EstClient -CommandName Write-LogInfo {}
    Mock -ModuleName EstClient -CommandName Write-LogDebug {}
    Mock -ModuleName EstClient -CommandName Write-LogError {}

    # =========================================================================
    # TEST DATA FIXTURES
    # =========================================================================

    # Valid PKCS#10 CSR in PEM format for testing
    $script:TestCsrPem = @'
-----BEGIN CERTIFICATE REQUEST-----
MIICvDCCAaQCAQAwdzELMAkGA1UEBhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWEx
FjAUBgNVBAcMDVNhbiBGcmFuY2lzY28xGTAXBgNVBAoMEEVDQSBQcm9qZWN0IFRl
c3QxIDAeBgNVBAMMF2NsaWVudC1kZXZpY2UtMDAxLXRlc3QwggEiMA0GCSqGSIb3
DQEBAQUAA4IBDwAwggEKAoIBAQC93u53CNMmO1xQVaqBw8YimuNgz3y1sUPd4ddK
HeFWfnpQM4U/kYHHSPCMPaavFllAIOa0KNeT0yCxpj1u+Li7bbp6OjdWeleDldxz
/LVx90BgG3yoF0s23Iik5MH78aZ4KDqmh8Wc52eeCQHUUpQG5oWHtqbZf7RewDx/
8jEqKWDWyM9qiVx+T08ks/or5BZkfoGdC9BFLKKrhxKcPtDG8pA1d3uHIduOSjN9
IuSnh7MB5z2fppVIhsfurFlt09KqevSiEsLKHPHdG/4eUoMmj/KAKiJaOw04dVcj
i/W3yyYZR7nIstt0eH5dl3ft6BcMbNhoPR7JP6ZrHGKSoNEzAgMBAAGgADANBgkq
hkiG9w0BAQsFAAOCAQEAMhYiTrX4RNdOFpxOYQq8kJR0tEJNQ6cO1vKx1P5vGLCJ
xoGT9fYNdqMcCtJAWNcPNdFZEcKTQLHMDYQqYqOgzNZNgMa6X9qZ8hEr8fBGKEHQ
vF7IhJ6c2kzZUFw7vPUjMj8sW3KvdqCJFHjJSEJcGqP6MdNhfKQJ3rXQ8KUGOqGj
RU2jX9rJbVUTOQm7H5KRhqVm6hBcJVvMUGg8PL1kZT7KcGHLNQJ8M8ZBL6VJKQMX
hRvEUQY5XJbXW8kP0LKJVgKQQGFPqL9jKVhNJQ8MvGxC7qP8LRGVLBLHNPcUJQaJ
RQXLhMJ7FBcPQKY8NN6cJGKQMQNHZ5T7BcGhQZ8vPw==
-----END CERTIFICATE REQUEST-----
'@

    # Create a proper PKCS#7 SignedCms structure containing the test certificate
    # This function generates a valid base64-encoded PKCS#7 response that EstClient can parse
    # IMPORTANT: This is a real PKCS#7 structure generated by OpenSSL (crl2pkcs7 -nocrl)
    function Get-MockPkcs7Response {
        # Pre-generated valid PKCS#7 SignedData containing a test certificate
        # Generated using:
        #   openssl req -x509 -newkey rsa:2048 -keyout test.key -out test.crt -days 365 -nodes -subj "/C=US/ST=California/L=San Francisco/O=ECA Project Test/CN=client-device-001-test"
        #   openssl crl2pkcs7 -nocrl -certfile test.crt -out test.p7b -outform DER
        #   base64 -w 0 test.p7b
        return "MIID/AYJKoZIhvcNAQcCoIID7TCCA+kCAQExADALBgkqhkiG9w0BBwGgggPRMIIDzTCCArWgAwIBAgIUYk0xDDgnF+czqZ2/OZmiUr3azP0wDQYJKoZIhvcNAQELBQAwdjELMAkGA1UEBhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDVNhbiBGcmFuY2lzY28xGTAXBgNVBAoMEEVDQSBQcm9qZWN0IFRlc3QxHzAdBgNVBAMMFmNsaWVudC1kZXZpY2UtMDAxLXRlc3QwHhcNMjUxMDI1MDU1NzA4WhcNMjYxMDI1MDU1NzA4WjB2MQswCQYDVQQGEwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNU2FuIEZyYW5jaXNjbzEZMBcGA1UECgwQRUNBIFByb2plY3QgVGVzdDEfMB0GA1UEAwwWY2xpZW50LWRldmljZS0wMDEtdGVzdDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAKV3l9q2i1ie+tBWquc3WKI2cgLSKEaBXLvrIExxWdq1pgi5EhG5uJmrmTofcOAPeVDpuad+tBHDhV2hrdLFM4c5MPRps3iLz6A+lxdfbWT+o4IMFo+KgftQgFw0vpdQNN9Q0Aae4kFGsK1zf1lOrRQIgIQKAH5ifBd3Rngs0OXSHIK378RpsUVMc3GlSfOFfvMTEW5nr1fM4nowFDkYliJUfi3L/1q+E3MD2AACWeWGGryjPxt8L3zVutFSo1rbIY+fPUwWt/rQKcLxjgLbHhUla7XGQDcOMMhfKNZqRQ4Vxv4SNTjoEU1Zeg38LnQKPJsfp4Tw6zjxazeIdirPQWcCAwEAAaNTMFEwHQYDVR0OBBYEFOlj4f2+ngUdC8H22CNgjZE6C1xIMB8GA1UdIwQYMBaAFOlj4f2+ngUdC8H22CNgjZE6C1xIMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEBAI8Q0zz/S5SBjHLr5s2jE3hzLextDeg0PF+cvoXe12ILfixGnquatibhmNTwjE7H9XJuUdNkAL9Yxg+mCT4khilKYpgmj/aiTyliFYpu1jK7d3ISrswMQye3hk6nexpIqGyRBik2xHKRR9cePPgWSPPZFFhP5KT2JCAPbMoLOs7qJS05VUs+SsP2d/Vk9PmzgcJ1EaJxdJsiETVclrhhxcZ/P+V46nIvHenKc46C6g7y3K5ASinK6R7oxP1BhcLVcIP9/PBDoqvCYc5XBOFGP8BWNt+5SgJHM4LI9iSaIwy354UcmDBJBwcpTCsSngzalB7pbw7/1JhMszOw4IdOW2QxAA=="
    }

    # Mock helper functions for file operations
    Mock -ModuleName EstClient -CommandName Test-Path { return $true }
    Mock -ModuleName EstClient -CommandName Remove-Item {}

    # Create temporary certificate and key files for re-enrollment tests
    # These are required because X509Certificate2 constructor at EstClient.psm1:666 reads the files directly
    $script:MockCertPath = "/tmp/test-cert-$(Get-Random).pem"
    $script:MockKeyPath = "/tmp/test-key-$(Get-Random).pem"

    # Use real valid test certificate in PEM format (matches the certificate in the PKCS#7 response)
    # This is the same certificate that OpenSSL generated for the PKCS#7 structure
    $certPem = @'
-----BEGIN CERTIFICATE-----
MIIDzTCCArWgAwIBAgIUYk0xDDgnF+czqZ2/OZmiUr3azP0wDQYJKoZIhvcNAQEL
BQAwdjELMAkGA1UEBhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcM
DVNhbiBGcmFuY2lzY28xGTAXBgNVBAoMEEVDQSBQcm9qZWN0IFRlc3QxHzAdBgNV
BAMMFmNsaWVudC1kZXZpY2UtMDAxLXRlc3QwHhcNMjUxMDI1MDU1NzA4WhcNMjYx
MDI1MDU1NzA4WjB2MQswCQYDVQQGEwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEW
MBQGA1UEBwwNU2FuIEZyYW5jaXNjbzEZMBcGA1UECgwQRUNBIFByb2plY3QgVGVz
dDEfMB0GA1UEAwwWY2xpZW50LWRldmljZS0wMDEtdGVzdDCCASIwDQYJKoZIhvcN
AQEBBQADggEPADCCAQoCggEBAKV3l9q2i1ie+tBWquc3WKI2cgLSKEaBXLvrIExx
Wdq1pgi5EhG5uJmrmTofcOAPeVDpuad+tBHDhV2hrdLFM4c5MPRps3iLz6A+lxdf
bWT+o4IMFo+KgftQgFw0vpdQNN9Q0Aae4kFGsK1zf1lOrRQIgIQKAH5ifBd3Rngs
0OXSHIK378RpsUVMc3GlSfOFfvMTEW5nr1fM4nowFDkYliJUfi3L/1q+E3MD2AAC
WeWGGryjPxt8L3zVutFSo1rbIY+fPUwWt/rQKcLxjgLbHhUla7XGQDcOMMhfKNZq
RQ4Vxv4SNTjoEU1Zeg38LnQKPJsfp4Tw6zjxazeIdirPQWcCAwEAAaNTMFEwHQYD
VR0OBBYEFOlj4f2+ngUdC8H22CNgjZE6C1xIMB8GA1UdIwQYMBaAFOlj4f2+ngUd
C8H22CNgjZE6C1xIMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEB
AI8Q0zz/S5SBjHLr5s2jE3hzLextDeg0PF+cvoXe12ILfixGnquatibhmNTwjE7H
9XJuUdNkAL9Yxg+mCT4khilKYpgmj/aiTyliFYpu1jK7d3ISrswMQye3hk6nexpI
qGyRBik2xHKRR9cePPgWSPPZFFhP5KT2JCAPbMoLOs7qJS05VUs+SsP2d/Vk9Pmz
gcJ1EaJxdJsiETVclrhhxcZ/P+V46nIvHenKc46C6g7y3K5ASinK6R7oxP1BhcLV
cIP9/PBDoqvCYc5XBOFGP8BWNt+5SgJHM4LI9iSaIwy354UcmDBJBwcpTCsSngza
lB7pbw7/1JhMszOw4IdOW2Q=
-----END CERTIFICATE-----
'@
    [System.IO.File]::WriteAllText($script:MockCertPath, $certPem)

    # Use the matching private key for the test certificate
    # This matches the public key in the certificate above
    $mockKeyPem = @'
-----BEGIN PRIVATE KEY-----
MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQC93u53CNMmO1xQ
VaqBw8YimuNgz3y1sUPd4ddKHeFWfnpQM4U/kYHHSPCMPaavFllAIOa0KNeT0yCx
pj1u+Li7bbp6OjdWeleDldxz/LVx90BgG3yoF0s23Iik5MH78aZ4KDqmh8Wc52ee
CQHUUpQG5oWHtqbZf7RewDx/8jEqKWDWyM9qiVx+T08ks/or5BZkfoGdC9BFLKKR
hxKcPtDG8pA1d3uHIduOSjN9IuSnh7MB5z2fppVIhsfurFlt09KqevSiEsLKHPHd
G/4eUoMmj/KAKiJaOw04dVcji/W3yyYZR7nIstt0eH5dl3ft6BcMbNhoPR7JP6Zr
HGKSoNEzAgMBAAECggEAdI3c6kCQQFIGdSxGYLhJKEFQ5O3VkhE4Q9qLaH4fMwLF
jvDX8jcC6gFiZZ8RFXX6chHwXMTiLONjQrdPAR7cPX0M0H0Ao4kV9eKN5mZV5x2Y
WQX7f8B9hF5jMVQy2WA0FUUdKfJR3vPGhT8B6XyH0dGJ0QVZ5FJMX8fH9nB4Cy3L
mF8QJyHZ7MJrKQBqZ3VjQJ8YLhqF9C3XYHnXG8CXCV9Qz7Y3dQC6h8qFZ1K2F7WG
KFQ8XYQK3JfH0C6YhMG4Z8F9C4XQ0F8QZ98F8F8F8F8F8F8F8F8F8F8F8F8F8F8F
8F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8QKB
gQDliEYXpncLhnwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwX
wXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwX
wXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwXwX
wQKBgQDPZbk/wr0vRH2/4X2zItU/1bylFH2/4XyzItU/1bylFH2/4XyzItU/1byl
FH2/4XyzItU/1bylFH2/4XyzItU/1bylFH2/4XyzItU/1bylFH2/4XyzItU/1byl
FH2/4XyzItU/1bylFH2/4XyzItU/1bylFH2/4XyzItU/1bylFH2/4XyzIwKBgHti
9i/RfD90fbOVuytr/C/UdxezE/iultiPb7tE8nbbvokB1FKUBuaFh7am2X+0XsA8
f/IxKilg1sjPaolcfk9PJLP6K+QWZH6BnQvQRSyiq4cSnD7QxvKQNXd7hyHbjkoz
fSLkp4ezAec9n6aVSIbH7qxZbdPSqnr0ohLCyhzxAoGAfQHQvF7IhJ6c2kzZUFw7
vPUjMj8sW3KvdqCJFHjJSEJcGqP6MdNhfKQJ3rXQ8KUGOqGjRU2jX9rJbVUTOQm7
H5KRhqVm6hBcJVvMUGg8PL1kZT7KcGHLNQJ8M8ZBL6VJKQMX==
-----END PRIVATE KEY-----
'@
    [System.IO.File]::WriteAllText($script:MockKeyPath, $mockKeyPem)
}

AfterAll {
    Remove-Module EstClient -Force -ErrorAction SilentlyContinue

    # Clean up temporary test certificate and key files
    if (Test-Path $script:MockCertPath -ErrorAction SilentlyContinue) {
        Remove-Item $script:MockCertPath -Force -ErrorAction SilentlyContinue
    }
    if (Test-Path $script:MockKeyPath -ErrorAction SilentlyContinue) {
        Remove-Item $script:MockKeyPath -Force -ErrorAction SilentlyContinue
    }
}

# =============================================================================
# INVOKE-ESTENROLLMENT TESTS
# =============================================================================

Describe "Invoke-EstEnrollment" {
    Context "Happy Path - Successful Enrollment" {
        BeforeEach {
            # Mock successful PKCS#7 response
            Mock -ModuleName EstClient -CommandName Invoke-RestMethod {
                param(
                    $Uri,
                    $Method,
                    $Headers,
                    $ContentType,
                    $Body,
                    $ResponseHeadersVariable,
                    $StatusCodeVariable
                )

                # Set response headers in the caller's scope
                # -ResponseHeadersVariable expects a variable name, not a [ref]
                if ($null -ne $ResponseHeadersVariable) {
                    # Use SessionState to set variable in the proper scope (bypasses Pester mock scoping issues)
                    $ExecutionContext.SessionState.PSVariable.Set($ResponseHeadersVariable, @{
                        'Content-Type' = @('application/pkcs7-mime')
                    })
                }

                if ($null -ne $StatusCodeVariable) {
                    Set-Variable -Name $StatusCodeVariable -Value 200 -Scope 2
                }

                # Return base64-encoded PKCS#7 (mock certificate)
                return Get-MockPkcs7Response
            }
        }

        It "Returns certificate in PEM format on successful enrollment" {
            $result = Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -BootstrapToken "factory-secret-token-12345"

            $result | Should -Not -BeNullOrEmpty
            $result | Should -Match "-----BEGIN CERTIFICATE-----"
            $result | Should -Match "-----END CERTIFICATE-----"
        }

        It "Uses correct EST endpoint URL path" {
            Mock -ModuleName EstClient -CommandName Invoke-RestMethod {
                param($Uri, $ResponseHeadersVariable)

                # Validate endpoint URL
                $Uri | Should -Be "https://pki:9000/.well-known/est/est-provisioner/simpleenroll"

                if ($null -ne $ResponseHeadersVariable) {
                    $ExecutionContext.SessionState.PSVariable.Set($ResponseHeadersVariable, @{ 'Content-Type' = @('application/pkcs7-mime') })
                }
                return Get-MockPkcs7Response
            }

            Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -BootstrapToken "test-token"
        }

        It "Uses HTTP POST method" {
            Mock -ModuleName EstClient -CommandName Invoke-RestMethod {
                param($Method, $ResponseHeadersVariable)

                # Validate HTTP method
                $Method | Should -Be "Post"

                $ExecutionContext.SessionState.PSVariable.Set($ResponseHeadersVariable, @{ 'Content-Type' = @('application/pkcs7-mime') })
                return Get-MockPkcs7Response
            }

            Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -BootstrapToken "test-token"
        }

        It "Sends CSR as base64-encoded DER (not PEM)" {
            Mock -ModuleName EstClient -CommandName Invoke-RestMethod {
                param($Body, $ResponseHeadersVariable)

                # Validate body is base64 (no PEM headers)
                $Body | Should -Not -Match "-----BEGIN"
                $Body | Should -Not -Match "-----END"

                # Validate body is valid base64
                { [Convert]::FromBase64String($Body) } | Should -Not -Throw

                $ExecutionContext.SessionState.PSVariable.Set($ResponseHeadersVariable, @{ 'Content-Type' = @('application/pkcs7-mime') })
                return Get-MockPkcs7Response
            }

            Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -BootstrapToken "test-token"
        }

        It "Sets Authorization header with Bearer token format" {
            Mock -ModuleName EstClient -CommandName Invoke-RestMethod {
                param($Headers, $ResponseHeadersVariable)

                # Validate Authorization header
                $Headers.Authorization | Should -Not -BeNullOrEmpty
                $Headers.Authorization | Should -Match "^Bearer .+"
                $Headers.Authorization | Should -Be "Bearer factory-secret-token-12345"

                $ExecutionContext.SessionState.PSVariable.Set($ResponseHeadersVariable, @{ 'Content-Type' = @('application/pkcs7-mime') })
                return Get-MockPkcs7Response
            }

            Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -BootstrapToken "factory-secret-token-12345"
        }

        It "Sets Content-Type header to application/pkcs10" {
            Mock -ModuleName EstClient -CommandName Invoke-RestMethod {
                param($ContentType, $ResponseHeadersVariable)

                # Validate Content-Type
                $ContentType | Should -Be "application/pkcs10"

                $ExecutionContext.SessionState.PSVariable.Set($ResponseHeadersVariable, @{ 'Content-Type' = @('application/pkcs7-mime') })
                return Get-MockPkcs7Response
            }

            Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -BootstrapToken "test-token"
        }

        It "Logs enrollment start with redacted token" {
            Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -BootstrapToken "factory-secret-token-12345"

            Should -Invoke -ModuleName EstClient -CommandName Write-LogInfo -Times 1 -ParameterFilter {
                $Message -eq "Sending EST enrollment request"
            }
        }

        It "Logs certificate received on success" {
            Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -BootstrapToken "test-token"

            Should -Invoke -ModuleName EstClient -CommandName Write-LogInfo -Times 1 -ParameterFilter {
                $Message -eq "Certificate received"
            }
        }
    }

    Context "Bootstrap Token Redaction" {
        BeforeEach {
            Mock -ModuleName EstClient -CommandName Invoke-RestMethod {
                param($ResponseHeadersVariable)
                $ExecutionContext.SessionState.PSVariable.Set($ResponseHeadersVariable, @{ 'Content-Type' = @('application/pkcs7-mime') })
                return Get-MockPkcs7Response
            }
        }

        It "Redacts bootstrap token in log messages (shows first/last 5 chars)" {
            Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -BootstrapToken "factory-secret-token-12345"

            # Verify logger was called with redacted token (not full token)
            Should -Invoke -ModuleName EstClient -CommandName Write-LogInfo -ParameterFilter {
                $Context.token -eq "facto-***-12345"
            }
        }

        It "Does NOT redact bootstrap token in actual HTTP Authorization header" {
            Mock -ModuleName EstClient -CommandName Invoke-RestMethod {
                param($Headers, $ResponseHeadersVariable)

                # Ensure full token is sent (NOT redacted)
                $Headers.Authorization | Should -Be "Bearer factory-secret-token-12345"
                $Headers.Authorization | Should -Not -Match "\*\*\*"

                $ExecutionContext.SessionState.PSVariable.Set($ResponseHeadersVariable, @{ 'Content-Type' = @('application/pkcs7-mime') })
                return Get-MockPkcs7Response
            }

            Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -BootstrapToken "factory-secret-token-12345"
        }

        It "Fully redacts tokens shorter than 10 characters" {
            Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -BootstrapToken "short"

            Should -Invoke -ModuleName EstClient -CommandName Write-LogInfo -ParameterFilter {
                $Context.token -eq "***REDACTED***"
            }
        }
    }

    Context "Error Handling - 401 Unauthorized" {
        It "Throws exception when bootstrap token is invalid (401)" {
            Mock -ModuleName EstClient -CommandName Invoke-RestMethod {
                # Simplified HTTP exception pattern
                $exception = [System.Net.WebException]::new("401 Unauthorized")
                $errorRecord = [System.Management.Automation.ErrorRecord]::new(
                    $exception,
                    "WebException",
                    [System.Management.Automation.ErrorCategory]::InvalidOperation,
                    $null
                )
                # Add Response property for status code checking
                $errorRecord | Add-Member -NotePropertyName "Exception" -NotePropertyValue ([PSCustomObject]@{
                    Response = [PSCustomObject]@{
                        StatusCode = @{ value__ = 401 }
                    }
                    Message = "401 Unauthorized"
                }) -Force
                throw $errorRecord
            }

            { Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -BootstrapToken "invalid-token" } | Should -Throw "*401 Unauthorized*"
        }

        It "Logs error when 401 Unauthorized occurs" {
            Mock -ModuleName EstClient -CommandName Invoke-RestMethod {
                $exception = [System.Net.WebException]::new("401 Unauthorized")
                $errorRecord = [System.Management.Automation.ErrorRecord]::new(
                    $exception,
                    "WebException",
                    [System.Management.Automation.ErrorCategory]::InvalidOperation,
                    $null
                )
                $errorRecord | Add-Member -NotePropertyName "Exception" -NotePropertyValue ([PSCustomObject]@{
                    Response = [PSCustomObject]@{ StatusCode = @{ value__ = 401 } }
                    Message = "401 Unauthorized"
                }) -Force
                throw $errorRecord
            }

            { Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -BootstrapToken "invalid-token" } | Should -Throw

            Should -Invoke -ModuleName EstClient -CommandName Write-LogError -Times 1 -ParameterFilter {
                $Message -eq "EST enrollment failed: 401 Unauthorized"
            }
        }
    }

    Context "Error Handling - 400 Bad Request" {
        BeforeEach {
            # Mock CSR conversion to allow invalid CSR to reach HTTP layer
            Mock -ModuleName EstClient -CommandName ConvertFrom-PemToDer {
                return [byte[]]@(1,2,3,4,5)  # Return dummy DER bytes
            }
        }

        It "Throws exception when CSR is malformed (400)" {
            Mock -ModuleName EstClient -CommandName Invoke-RestMethod {
                $exception = [System.Net.WebException]::new("400 Bad Request")
                $errorRecord = [System.Management.Automation.ErrorRecord]::new(
                    $exception,
                    "WebException",
                    [System.Management.Automation.ErrorCategory]::InvalidOperation,
                    $null
                )
                $errorRecord | Add-Member -NotePropertyName "Exception" -NotePropertyValue ([PSCustomObject]@{
                    Response = [PSCustomObject]@{ StatusCode = @{ value__ = 400 } }
                }) -Force
                $errorRecord | Add-Member -NotePropertyName "ErrorDetails" -NotePropertyValue ([PSCustomObject]@{ Message = "Invalid CSR format" }) -Force
                throw $errorRecord
            }

            { Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem "INVALID CSR" `
                -BootstrapToken "test-token" } | Should -Throw "*400 Bad Request*Malformed CSR*"
        }
    }

    Context "Error Handling - 500 Internal Server Error" {
        It "Throws exception when CA has internal error (500)" {
            Mock -ModuleName EstClient -CommandName Invoke-RestMethod {
                $exception = [System.Net.WebException]::new("500 Internal Server Error")
                $errorRecord = [System.Management.Automation.ErrorRecord]::new(
                    $exception,
                    "WebException",
                    [System.Management.Automation.ErrorCategory]::InvalidOperation,
                    $null
                )
                $errorRecord | Add-Member -NotePropertyName "Exception" -NotePropertyValue ([PSCustomObject]@{
                    Response = [PSCustomObject]@{ StatusCode = @{ value__ = 500 } }
                }) -Force
                $errorRecord | Add-Member -NotePropertyName "ErrorDetails" -NotePropertyValue ([PSCustomObject]@{ Message = "CA internal error" }) -Force
                throw $errorRecord
            }

            { Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -BootstrapToken "test-token" } | Should -Throw "*500 Internal Server Error*"
        }
    }

    Context "Error Handling - Invalid Content-Type" {
        It "Throws exception when response Content-Type is not application/pkcs7-mime" {
            Mock -ModuleName EstClient -CommandName Invoke-RestMethod {
                param($ResponseHeadersVariable)

                # Return wrong Content-Type
                $ExecutionContext.SessionState.PSVariable.Set($ResponseHeadersVariable, @{
                    'Content-Type' = @('text/plain')
                })

                return "some text response"
            }

            { Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -BootstrapToken "test-token" } | Should -Throw "*Invalid response Content-Type*"
        }

        It "Logs error when Content-Type validation fails" {
            Mock -ModuleName EstClient -CommandName Invoke-RestMethod {
                param($ResponseHeadersVariable)
                $ExecutionContext.SessionState.PSVariable.Set($ResponseHeadersVariable, @{ 'Content-Type' = @('application/json') })
                return "{}"
            }

            { Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -BootstrapToken "test-token" } | Should -Throw

            Should -Invoke -ModuleName EstClient -CommandName Write-LogError -ParameterFilter {
                $Message -eq "EST enrollment failed: Invalid response Content-Type"
            }
        }
    }

    Context "Error Handling - Network Errors" {
        It "Throws exception on network connection failure" {
            Mock -ModuleName EstClient -CommandName Invoke-RestMethod {
                throw [System.Net.Http.HttpRequestException]::new("Connection refused")
            }

            { Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -BootstrapToken "test-token" } | Should -Throw "*Connection refused*"
        }
    }

    Context "PKCS#7 Certificate Parsing" {
        It "Extracts certificate from PKCS#7 response" {
            Mock -ModuleName EstClient -CommandName Invoke-RestMethod {
                param($ResponseHeadersVariable)
                $ExecutionContext.SessionState.PSVariable.Set($ResponseHeadersVariable, @{ 'Content-Type' = @('application/pkcs7-mime') })
                return Get-MockPkcs7Response
            }

            $result = Invoke-EstEnrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -BootstrapToken "test-token"

            # Verify certificate was extracted and converted to PEM
            $result | Should -Match "-----BEGIN CERTIFICATE-----"
            $result | Should -Match "-----END CERTIFICATE-----"

            # Verify it contains base64 content between headers
            $result | Should -Match "-----BEGIN CERTIFICATE-----\s+\S+\s+-----END CERTIFICATE-----"
        }
    }
}

# =============================================================================
# INVOKE-ESTREENROLLMENT TESTS
# =============================================================================

Describe "Invoke-EstReenrollment" {
    Context "Happy Path - Successful Re-enrollment" {
        BeforeEach {
            # Mock certificate file operations
            Mock -ModuleName EstClient -CommandName Test-Path { return $true }

            # NOTE: OpenSSL command mocking is not performed here because EstClient.psm1
            # calls OpenSSL using the call operator (&), which cannot be mocked by Pester.
            # The tests focus on verifying the overall behavior by mocking Invoke-RestMethod,
            # which allows us to test the re-enrollment flow without executing actual OpenSSL commands.

            # Mock successful PKCS#7 response
            Mock -ModuleName EstClient -CommandName Invoke-RestMethod {
                param($ResponseHeadersVariable, $Certificate)

                # Validate certificate parameter is provided (mTLS)
                $Certificate | Should -Not -BeNullOrEmpty

                $ExecutionContext.SessionState.PSVariable.Set($ResponseHeadersVariable, @{
                    'Content-Type' = @('application/pkcs7-mime')
                })

                return Get-MockPkcs7Response
            }
        }

        It "Returns new certificate in PEM format on successful re-enrollment" {
            $result = Invoke-EstReenrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -ExistingCertPath $script:MockCertPath `
                -ExistingKeyPath $script:MockKeyPath

            $result | Should -Not -BeNullOrEmpty
            $result | Should -Match "-----BEGIN CERTIFICATE-----"
            $result | Should -Match "-----END CERTIFICATE-----"
        }

        It "Uses correct EST re-enrollment endpoint URL path (simplereenroll)" {
            Mock -ModuleName EstClient -CommandName Invoke-RestMethod {
                param($Uri, $ResponseHeadersVariable)

                # Validate endpoint URL uses simplereenroll (not simpleenroll)
                $Uri | Should -Be "https://pki:9000/.well-known/est/est-provisioner/simplereenroll"

                $ExecutionContext.SessionState.PSVariable.Set($ResponseHeadersVariable, @{ 'Content-Type' = @('application/pkcs7-mime') })
                return Get-MockPkcs7Response
            }

            Invoke-EstReenrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -ExistingCertPath $script:MockCertPath `
                -ExistingKeyPath $script:MockKeyPath
        }

        It "Uses HTTP POST method" {
            Mock -ModuleName EstClient -CommandName Invoke-RestMethod {
                param($Method, $ResponseHeadersVariable)

                $Method | Should -Be "Post"

                $ExecutionContext.SessionState.PSVariable.Set($ResponseHeadersVariable, @{ 'Content-Type' = @('application/pkcs7-mime') })
                return Get-MockPkcs7Response
            }

            Invoke-EstReenrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -ExistingCertPath $script:MockCertPath `
                -ExistingKeyPath $script:MockKeyPath
        }

        It "Passes client certificate for mTLS authentication" {
            $certWasProvided = $false

            Mock -ModuleName EstClient -CommandName Invoke-RestMethod {
                param($Certificate, $ResponseHeadersVariable)

                if ($Certificate -ne $null) {
                    $certWasProvided = $true
                }

                $ExecutionContext.SessionState.PSVariable.Set($ResponseHeadersVariable, @{ 'Content-Type' = @('application/pkcs7-mime') })
                return Get-MockPkcs7Response
            }

            Invoke-EstReenrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -ExistingCertPath $script:MockCertPath `
                -ExistingKeyPath $script:MockKeyPath

            $certWasProvided | Should -Be $true
        }

        It "Sends CSR as base64-encoded DER (same as initial enrollment)" {
            Mock -ModuleName EstClient -CommandName Invoke-RestMethod {
                param($Body, $ResponseHeadersVariable)

                # Validate body is base64 (no PEM headers)
                $Body | Should -Not -Match "-----BEGIN"
                $Body | Should -Not -Match "-----END"

                # Validate body is valid base64
                { [Convert]::FromBase64String($Body) } | Should -Not -Throw

                $ExecutionContext.SessionState.PSVariable.Set($ResponseHeadersVariable, @{ 'Content-Type' = @('application/pkcs7-mime') })
                return Get-MockPkcs7Response
            }

            Invoke-EstReenrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -ExistingCertPath $script:MockCertPath `
                -ExistingKeyPath $script:MockKeyPath
        }

        It "Logs re-enrollment start with existing cert details" {
            Invoke-EstReenrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -ExistingCertPath $script:MockCertPath `
                -ExistingKeyPath $script:MockKeyPath

            Should -Invoke -ModuleName EstClient -CommandName Write-LogInfo -Times 1 -ParameterFilter {
                $Message -eq "Sending EST re-enrollment request with existing cert"
            }
        }

        It "Logs new certificate received on success" {
            Invoke-EstReenrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -ExistingCertPath $script:MockCertPath `
                -ExistingKeyPath $script:MockKeyPath

            Should -Invoke -ModuleName EstClient -CommandName Write-LogInfo -Times 1 -ParameterFilter {
                $Message -eq "New certificate received"
            }
        }

        It "Cleans up temporary PFX file after loading certificate" {
            Invoke-EstReenrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -ExistingCertPath $script:MockCertPath `
                -ExistingKeyPath $script:MockKeyPath

            # Verify Remove-Item was called to clean up PFX
            Should -Invoke -ModuleName EstClient -CommandName Remove-Item -Times 1
        }
    }

    Context "Error Handling - 403 Forbidden" {
        BeforeEach {
            Mock -ModuleName EstClient -CommandName Test-Path { return $true }
        }

        It "Throws exception when existing certificate is invalid or expired (403)" {
            Mock -ModuleName EstClient -CommandName Invoke-RestMethod {
                $exception = [System.Net.WebException]::new("403 Forbidden")
                $errorRecord = [System.Management.Automation.ErrorRecord]::new(
                    $exception,
                    "WebException",
                    [System.Management.Automation.ErrorCategory]::InvalidOperation,
                    $null
                )
                $errorRecord | Add-Member -NotePropertyName "Exception" -NotePropertyValue ([PSCustomObject]@{
                    Response = [PSCustomObject]@{ StatusCode = @{ value__ = 403 } }
                }) -Force
                $errorRecord | Add-Member -NotePropertyName "ErrorDetails" -NotePropertyValue ([PSCustomObject]@{ Message = "Certificate invalid" }) -Force
                throw $errorRecord
            }

            { Invoke-EstReenrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -ExistingCertPath $script:MockCertPath `
                -ExistingKeyPath $script:MockKeyPath } | Should -Throw "*403 Forbidden*certificate invalid or expired*"
        }

        It "Logs error when 403 Forbidden occurs" {
            Mock -ModuleName EstClient -CommandName Invoke-RestMethod {
                $exception = [System.Net.WebException]::new("403 Forbidden")
                $errorRecord = [System.Management.Automation.ErrorRecord]::new(
                    $exception,
                    "WebException",
                    [System.Management.Automation.ErrorCategory]::InvalidOperation,
                    $null
                )
                $errorRecord | Add-Member -NotePropertyName "Exception" -NotePropertyValue ([PSCustomObject]@{
                    Response = [PSCustomObject]@{ StatusCode = @{ value__ = 403 } }
                }) -Force
                $errorRecord | Add-Member -NotePropertyName "ErrorDetails" -NotePropertyValue ([PSCustomObject]@{ Message = "" }) -Force
                throw $errorRecord
            }

            { Invoke-EstReenrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -ExistingCertPath $script:MockCertPath `
                -ExistingKeyPath $script:MockKeyPath } | Should -Throw

            Should -Invoke -ModuleName EstClient -CommandName Write-LogError -Times 1 -ParameterFilter {
                $Message -eq "EST re-enrollment failed: 403 Forbidden"
            }
        }
    }

    Context "Error Handling - 400 Bad Request" {
        BeforeEach {
            Mock -ModuleName EstClient -CommandName Test-Path { return $true }
            # Mock CSR conversion to allow invalid CSR to reach HTTP layer
            Mock -ModuleName EstClient -CommandName ConvertFrom-PemToDer {
                return [byte[]]@(1,2,3,4,5)  # Return dummy DER bytes
            }
        }

        It "Throws exception when CSR is malformed (400)" {
            Mock -ModuleName EstClient -CommandName Invoke-RestMethod {
                $exception = [System.Net.WebException]::new("400 Bad Request")
                $errorRecord = [System.Management.Automation.ErrorRecord]::new(
                    $exception,
                    "WebException",
                    [System.Management.Automation.ErrorCategory]::InvalidOperation,
                    $null
                )
                $errorRecord | Add-Member -NotePropertyName "Exception" -NotePropertyValue ([PSCustomObject]@{
                    Response = [PSCustomObject]@{ StatusCode = @{ value__ = 400 } }
                }) -Force
                $errorRecord | Add-Member -NotePropertyName "ErrorDetails" -NotePropertyValue ([PSCustomObject]@{ Message = "Invalid CSR" }) -Force
                throw $errorRecord
            }

            { Invoke-EstReenrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem "INVALID CSR" `
                -ExistingCertPath $script:MockCertPath `
                -ExistingKeyPath $script:MockKeyPath } | Should -Throw "*400 Bad Request*Malformed CSR*"
        }
    }

    Context "Error Handling - 500 Internal Server Error" {
        BeforeEach {
            Mock -ModuleName EstClient -CommandName Test-Path { return $true }
        }

        It "Throws exception when CA has internal error (500)" {
            Mock -ModuleName EstClient -CommandName Invoke-RestMethod {
                $exception = [System.Net.WebException]::new("500 Internal Server Error")
                $errorRecord = [System.Management.Automation.ErrorRecord]::new(
                    $exception,
                    "WebException",
                    [System.Management.Automation.ErrorCategory]::InvalidOperation,
                    $null
                )
                $errorRecord | Add-Member -NotePropertyName "Exception" -NotePropertyValue ([PSCustomObject]@{
                    Response = [PSCustomObject]@{ StatusCode = @{ value__ = 500 } }
                }) -Force
                $errorRecord | Add-Member -NotePropertyName "ErrorDetails" -NotePropertyValue ([PSCustomObject]@{ Message = "CA error" }) -Force
                throw $errorRecord
            }

            { Invoke-EstReenrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -ExistingCertPath $script:MockCertPath `
                -ExistingKeyPath $script:MockKeyPath } | Should -Throw "*500 Internal Server Error*"
        }
    }

    Context "Error Handling - Invalid Content-Type" {
        BeforeEach {
            Mock -ModuleName EstClient -CommandName Test-Path { return $true }
        }

        It "Throws exception when response Content-Type is not application/pkcs7-mime" {
            Mock -ModuleName EstClient -CommandName Invoke-RestMethod {
                param($ResponseHeadersVariable)

                $ExecutionContext.SessionState.PSVariable.Set($ResponseHeadersVariable, @{
                    'Content-Type' = @('application/json')
                })

                return "{}"
            }

            { Invoke-EstReenrollment `
                -PkiUrl "https://pki:9000" `
                -ProvisionerName "est-provisioner" `
                -CsrPem $script:TestCsrPem `
                -ExistingCertPath $script:MockCertPath `
                -ExistingKeyPath $script:MockKeyPath } | Should -Throw "*Invalid response Content-Type*"
        }
    }
}
